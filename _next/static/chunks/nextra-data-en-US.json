{"/":{"title":"Introduction","data":{"":"JUnit Jupiter 기반 단위테스트\nMockito 기반 다양한 단위테스트\nSpring Reactive 에서의 테스트\n슬라이스 테스트 (Web, Data)\n통합 테스트"}},"/integration-test":{"title":"Integration Test","data":{"통합-테스트-integration-test#통합 테스트 (Integration Test)":""}},"/reactor-test/if-without-stepverifier":{"title":"If without Stepverifier","data":{"stepverifier-없이-테스트할-경우#StepVerifier 없이 테스트할 경우":"StepVerifier 없이 테스트할 경우의 단점들에 대해 알아봅니다.","1-데이터를-즉시-로딩하는-테스트#1) 데이터를 즉시 로딩하는 테스트":"@Test\r\npublic void TEST_FLUX_1_BY_TO_LIST_BLOCK(){\r\n    Flux<Integer> numbers = Flux.create(sink -> {\r\n      for(int i=0; i<10; i++) sink.next(i);\r\n      sink.complete();\r\n    });\r\n\r\n    var expectedList = IntStream.range(0, 10)\r\n        .boxed()\r\n        .collect(Collectors.toList());\r\n\r\n    var actualList = numbers.collectList().block();\r\n\r\n    Assertions.assertIterableEquals(expectedList, actualList);\r\n}\nStream 과 Iterable 의 차이점, 단점 등에서 자주 언급되듯, Iterable 은 모든 데이터를 한번에 전달해줍니다. 반면 Stream 은 데이터를 게으르게 전달해주며, 한번에 데이터를 모아서 전달해주는 방식이 아닙니다. Flux 역시도 데이터를 한번에 모아서 Publish 하는 Publisher 가 아닙니다.따라서 위의 코드 처럼 Flux 를 Iterable 로 변환해서 테스트하는 것은 비효율적입니다. 틀린 코드는 아니지만 Flux 의 장점을 활용하지 못한 코드입니다.","2-예외-발생-직전의-요건을-테스트하기-쉽지-않다#2) 예외 발생 직전의 요건을 테스트하기 쉽지 않다":"@Test\r\npublic void TEST_FLUX_2_THROW_EXCEPTION_STATEMENT(){\r\n    Flux<Integer> numbers = Flux.create(sink -> {\r\n      for(int i=0; i<10; i++) {\r\n        sink.next(i);\r\n        if(i==5) sink.error(new RuntimeException(\"잠깐 멈춰봐요\"));\r\n      }\r\n      sink.complete();\r\n    });\r\n\r\n    Assertions.assertThrows(RuntimeException.class, () -> {\r\n      numbers.collectList().block();\r\n    });\r\n}\ni=5 일 때 RuntimeException 을 내고 있습니다. 만약 RuntimeException 이 발생하기 전에 i=4 일때 어떤 값이 있었는지, 어떤 데이터였는지 요건을 파악하고 싶다면 어떻게 해야 할까요?  테스트를 위해서 Flux 의 바깥에 조건변수를 두거나 여러가지 제어 구문을 적용해야만 할 것입니다.위의 코드는 정상적인 코드이지만, Webflux 의 StepVerifier 를 활용한다면 조금 더 유연한 테스트가 가능해집니다."}},"/reactor-test/reactor-test":{"title":"Reactor Test","data":{}},"/mockito-test":{"title":"Mockito Test","data":{"mockito-테스트#Mockito 테스트":""}},"/slice-test":{"title":"Slice Test","data":{"슬라이스-테스트-slice-test#슬라이스 테스트 (Slice Test)":""}},"/reactor-test":{"title":"Reactor Test","data":{"reactor-테스트#Reactor 테스트":""}},"/test-tips":{"title":"Test Tips","data":{"테스트-tips#테스트 Tips":"Private 메서드 테스트\nTest 객체 생성\nTest Double 이 뭐에요?"}},"/test-tips/private-method-test":{"title":"Private Method Test","data":{"private-메서드-테스트#Private 메서드 테스트":""}},"/test-tips/what-is-test-double":{"title":"What Is Test Double","data":{"test-double-이-뭔가요#Test Double 이 뭔가요?":""}},"/test-tips/test-fixtures":{"title":"Test Fixtures","data":{"테스트-더미-객체-생성#테스트 더미 객체 생성":""}},"/unit-test":{"title":"Unit Test","data":{"유닛-테스트-unit-test#유닛 테스트 (Unit Test)":""}},"/unit-test/jupiter-assertions":{"title":"Jupiter Assertions","data":{"assertions-junit-jupiter#Assertions (Junit Jupiter)":"","asserttrue-assertfalse#assertTrue, assertFalse":"// 1)\r\n@Test\r\npublic void ASSERT_TRUE_FALSE_SIMPLE(){\r\n    boolean someTrue = true;\r\n    Assertions.assertTrue(someTrue);\r\n\r\n    boolean someFalse = false;\r\n    Assertions.assertFalse(someFalse);\r\n}\r\n\r\n// 2)\r\n@Test\r\npublic void ASSERT_TRUE_FALSE_SUPPLIER(){\r\n    Assertions.assertTrue(()-> {\r\n        return true;\r\n    });\r\n}\n1)\n값 기반으로 Assert 를 합니다.\n2)\nSupplier 에 대한 Assert 를 수행합니다.\n예를 들면 Spring Cloud Function 등을 사용할 경우 단순 값이 아닌 Supplier 를 리턴하는 경우도 꽤 많은데, 이런 경우 Supplier 를 그대로 넘겨주어서 assert 를 수행하는 것이 가능합니다.","assertequals-assertnotequals#assertEquals, assertNotEquals":"값을 비교하는 Assertion 입니다.\n// 1)\r\n@Test\r\npublic void ASSERT_EQUALS_NOT_EQUALS_1(){\r\n    String s1 = \"HELLO\";\r\n    String s2 = \"HELLO\";\r\n    Assertions.assertEquals(s1, s2);\r\n}\r\n\r\npublic class Message{\r\n    private String payload;\r\n    public Message(String payload){\r\n      this.payload = payload;\r\n    }\r\n}\r\n\r\n// 2)\r\n@Test\r\npublic void ASSERT_EQUALS_NOT_EQUALS_2(){\r\n    Message m1 = new Message(\"111\");\r\n    Message m2 = new Message(\"222\");\r\n    Assertions.assertNotEquals(m1, m2);\r\n}\n1)\ns1, s2 를 비교합니다. String 내에는 equals() 메서드가 정의되어 있기 때문에 s1, s2 를 Assertions.assertEquals() 로 비교 시에 같은 값으로 판단됩니다.\n2)\nm1, m2 를 비교합니다. Message 내에는 equals() 메서드가 정의되어 있지 않기 때문에 m1, m2 를 Assert.assertNotEquals() 로 비교시 참으로 인식됩니다.","assertsame-assertnotsame#assertSame, assertNotSame":"assertSame(), assertNotSame() 의 비교는 값의 비교가 아닌 참조의 비교를 수행합니다.\npublic class Box{\r\n    int weight;\r\n    public Box(int weight){\r\n      this.weight = weight;\r\n    }\r\n    @Override\r\n    public boolean equals(Object o) {\r\n      if (this == o) {\r\n        return true;\r\n      }\r\n      if (o == null || getClass() != o.getClass()) {\r\n        return false;\r\n      }\r\n      Box box = (Box) o;\r\n      return weight == box.weight;\r\n    }\r\n}\r\n\r\n@Test\r\npublic void ASSERT_SAME_NOT_SAME(){\r\n    // 1) \r\n    Box b1 = new Box(10);\r\n    Box b2 = new Box(10);\r\n    Assertions.assertNotSame(b1, b2);\r\n    Assertions.assertEquals(b1, b2);\r\n\r\n    // 2)\r\n    String s1 = \"Hello\";\r\n    Supplier<String> lazyS2 = () -> s1;\r\n    Assertions.assertSame(s1, lazyS2.get());\r\n}\n1)\nb1, b2 비교시 Box 클래스 내에는 equals() 메서드가 정의되어 있기에 assertEquals(b1, b2) 의 결과는 true 이며, 참조값의 비교시 b1, b2 는 서로 다른 메모리 참조값을 가지기에 assertNotSame(b1, b2) 를 통해 b1, b2 의 메모리 주소가 다르다는 것을 확인가능합니다.\n똑같은 s1 변수를 리턴하는 assert 입니다. assertSame() 은 메모리 참조를 비교하기 때문에 assertSame(s1, lazyS2.get()) 의 결과는 true 입니다.","assertarrayequals-assertiterableequals#assertArrayEquals, assertIterableEquals":"배열 또는 Iterable 타입에 대해 값의 비교를 확인해봅니다.\n@Test\r\npublic void ASSERT_ARRAY_EQUALS_AND_ITERABLE_EQUALS(){\r\n    // 1)\r\n    String [] actualArray = {\"A\", \"B\", \"C\"};\r\n    String [] expectedArray = {\"A\", \"B\", \"C\"};\r\n    Assertions.assertArrayEquals(actualArray, expectedArray);\r\n\r\n    // 2)\r\n    List<String> actualList = List.of(\"A\",\"B\",\"C\");\r\n    List<String> expectedList = List.of(\"A\",\"B\",\"C\");\r\n    Assertions.assertIterableEquals(actualList, expectedList);\r\n}\n1)\nactualArray 와 expectedArray 는 각 요소의 순서, 값 모두 일치합니다.\n2)\nactualList 와 expectedList 모두 각 요소의 순서, 값 모두 일치합니다.","assertlinesmatch#assertLinesMatch":"assertLinesMatch 는 두개의 스트림의 모든 요소가 순서와 값이 모두 일치하거나, 두개의 리스트의 모든 요소가 순서와 값이 모두 일치하는 경우를 테스트할 때 사용합니다.\n@Test\r\npublic void ASSERT_LINES_MATCH(){\r\n    // 1)\r\n    Stream<String> sourceStream = Stream.of(\"A\", \"B\", \"C\");\r\n    Stream<String> targetStream = Stream.of(\"A\", \"B\", \"C\");\r\n    Assertions.assertLinesMatch(sourceStream, targetStream);\r\n\r\n    // 2)\r\n    List<String> sourceList = List.of(\"A\", \"B\", \"C\");\r\n    List<String> targetList = List.of(\"A\", \"B\", \"C\");\r\n    Assertions.assertLinesMatch(sourceList, targetList);\r\n}\n1)\nStream 내의 모든 요소의 순서와 값이 일치하기에 테스트가 실패하지 않습니다.\n2)\nList 내의 모든 요소의 순서와 값이 일치하기에 테스트가 실패하지 않습니다.","assertnull-assertnotnull#assertNull, assertNotNull":"Null 인지, Null 이 아닌지를 검사합니다. 간단한 예제이기에 설명은 생략합니다.\n@Test\r\npublic void ASSERT_NULL_NOT_NULL(){\r\n    String nullStr = null;\r\n    Assertions.assertNull(nullStr);\r\n\r\n    String apple = \"APPLE\";\r\n    Assertions.assertNotNull(apple);\r\n}","assertinstanceof#assertInstanceOf":"특정 타입에 해당하는지 검사합니다.\n@Test\r\npublic void ASSERT_INSTANCE_OF(){\r\n    var exception = new RuntimeException(\"어머, 예외가 발생했어요.\");\r\n    Assertions.assertInstanceOf(RuntimeException.class, exception);\r\n}","fail#fail":"특정 케이스에 테스트를 실패시켜야 할 경우 Assert.fail() 을 방출하도록 합니다. 유지보수로 인해 생긴 변경에 대한 테스트 케이스를 수정해야 함을 파악하기에 좋은 방식입니다.\n@Test\r\npublic void ASSERT_FAIL(){\r\n    Logger log = LoggerFactory.getLogger(JUnitAssertionsTest.class);\r\n    var exception = new RuntimeException(\"어머, 예외가 발생했어요.\");\r\n\r\n    if(exception != null)\r\n      Assertions.fail();\r\n    else{\r\n      log.info(\"예외가 발생하지 않았어요. 정상이에요.\");\r\n    }\r\n}\r\n\r\n@Test\r\npublic void ASSERT_TEST_MUST_FAIL(){\r\n    Logger log = LoggerFactory.getLogger(JUnitAssertionsTest.class);\r\n    var exception = new RuntimeException(\"어머, 예외가 발생했어요.\");\r\n\r\n    if(exception != null)\r\n      Assertions.fail(exception);\r\n    else{\r\n      log.info(\"예외가 발생하지 않았어요. 정상이에요.\");\r\n    }\r\n}","assertall#assertAll":"특정 단언문들을 한꺼번에 실행하고 싶을때가 있습니다. 또는 즉시 로딩하는 연산대신 lazy loading 을 하는 연산을 수행하고 싶을 경우가 있습니다. 이런 경우 junit.jupiter 의 Executable 을 활용해서 아래와 같이 Assertions.assertAll(Executable executables...) 을 수행하면 됩니다.\n@Test\r\npublic void ASSERT_ALL(){\r\n    Assertions.assertAll(\r\n        () -> {Assertions.assertTrue(true);},\r\n        () -> {Assertions.assertTrue(1 > 0);},\r\n        () -> {Assertions.assertTrue(List.of(1,2,3).size() == 3);}\r\n    );\r\n\r\n    Stream<Executable> stream = Stream.of(\r\n        () -> {Assertions.assertTrue(true);},\r\n        () -> {Assertions.assertTrue(1 > 0);},\r\n        () -> {Assertions.assertTrue(List.of(1,2,3).size() == 3);}\r\n    );\r\n    Assertions.assertAll(stream);\r\n}","assertthrows-assertthrowsexactly#assertThrows, assertThrowsExactly":"특정 비즈니스 로직의 유효성 체크나, 요건이 성립하지 않는 경우를 테스트하기 위해 Exception 을 내는 테스트 케이스를 해야 할 경우가 많습니다. 또한 비즈니스 로직에 따라서 Exception 의 종류도 다양하게 정의하고 여러 가지 경우의 수로 나누어서 여러가지 Exception 을 throw 합니다. 이런 경우에 대한 테스트는 assertThrows, assertThrowsExactly 를 사용합니다.\n@Test\r\npublic void ASSERT_THROWS_ASSERT_THROWS_EXACTLY(){\r\n    Assertions.assertThrows(\r\n        IllegalStateException.class,\r\n        () -> {\r\n          throw new IllegalStateException(\"예외가 발생했어요\");\r\n        }\r\n    );\r\n\r\n    Assertions.assertThrows(\r\n        RuntimeException.class, // IllegalArgumentException 은 RuntimeException 의 한 종류로 판단\r\n        () -> {\r\n          throw new IllegalStateException(\"예외가 발생했어요\");\r\n        }\r\n    );\r\n\r\n    /** 테스트가 실패합니다.\r\n     * RuntimeException 은 IllegalStateException 의 상위타입입니다.\r\n    Assertions.assertThrows(\r\n        IllegalStateException.class,\r\n        () -> {\r\n          throw new RuntimeException(\"asdf\");\r\n        }\r\n    );\r\n    */\r\n\r\n    Assertions.assertThrowsExactly(\r\n        IllegalStateException.class,\r\n        () -> {\r\n          throw new IllegalStateException(\"예외가 발생했어요\");\r\n        }\r\n    );\r\n\r\n    /** 테스트가 실패합니다.\r\n     * IllegalStateException RuntimeException 의 한 종류이지만,\r\n     * Assertions.assertThrowsExactly 는 정확하게 타입이 일치해야만 성공으로 인식합니다.\r\n    Assertions.assertThrowsExactly(\r\n        RuntimeException.class,\r\n        () -> {\r\n          throw new IllegalStateException(\"예외가 발생했어요\");\r\n        }\r\n    );\r\n    */\r\n}","assertdoesnotthrow#assertDoesNotThrow":"Exception 이 발생하지 않음을 보장합니다.\n@Test\r\npublic void ASSERT_DOES_NOT_THROW(){\r\n    Assertions.assertDoesNotThrow(\r\n        () -> {}\r\n    );\r\n\r\n    Assertions.assertDoesNotThrow(\r\n        () -> \"안녕하세요\"\r\n    );\r\n}","asserttimeout#assertTimeout":"@Test\r\npublic void ASSERT_TIMOUT(){\r\n    final Duration timeLimit = Duration.ofSeconds(1);\r\n\r\n    Assertions.assertTimeout(timeLimit, () -> {\r\n      sleep(500);\r\n    });\r\n\r\n    var externalResult = Assertions.assertTimeout(timeLimit, () -> {\r\n      sleep(500);\r\n      return true;\r\n    });\r\n    Assertions.assertTrue(externalResult);\r\n\r\n    /** 실패하는 케이스 : 미리 지정한 1초의 타임아웃을 넘어서는 케이스\r\n    Assertions.assertTimeout(timeLimit, () -> {\r\n      sleep(2000);\r\n    });\r\n    */\r\n}\r\n\r\npublic void sleep(long ms){\r\n    try{\r\n      Thread.sleep(ms);\r\n    }\r\n    catch (Exception e){\r\n      e.printStackTrace();\r\n    }\r\n}","asserttimeoutpreemptively#assertTimeoutPreemptively":"참고자료 : Junit5 Assertions/Assumptions 설명\n예를 들어 아래의 코드는 10초동안 기다려야 테스트가 끝납니다.\npublic void sleep(long ms){\r\n    try{\r\n      Thread.sleep(ms);\r\n    }\r\n    catch (Exception e){\r\n      e.printStackTrace();\r\n    }\r\n}\r\n\r\n@Test\r\npublic void ASSERT_TIMEOUT_NO_PREEMPTIVELY(){\r\n    final Duration timeLimit = Duration.ofSeconds(8);\r\n\r\n    var externalResult = Assertions.assertTimeout(timeLimit, () -> {\r\n      sleep(7000);\r\n      return true;\r\n    });\r\n    Assertions.assertTrue(externalResult);\r\n}\n위의 테스트 코드를 1초 동안만 기다렸다가, 1초 내에 테스트가 끝나지 않으면 종료시키려 할 경우 아래와 같이 작성합니다. 아래 코드는 익셉션을 내면서 종료됩니다.\n@Disabled\r\n@TestMustFail\r\npublic void ASSERT_TIMEOUT_PREEMPTIVELY(){\r\n    final Duration timeLimit = Duration.ofSeconds(1);\r\n\r\n    var externalResult = Assertions.assertTimeoutPreemptively(timeLimit, () -> {\r\n      sleep(7000);\r\n      return true;\r\n    });\r\n    Assertions.assertTrue(externalResult);\r\n}\r\n\r\n// @TestMustFail 은 아래와 같이 정의해두었습니다.\r\n@Target(ElementType.METHOD)\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@Test\r\npublic @interface TestMustFail {\r\n\r\n}\nassertTimeoutPreemptively 를 사용하면 오래 걸리는 작업이 정해둔 타임아웃 내에 끝나지 않으면 작업을 종료시킵니다. 이 과정에서 익셉션이 발생하기도 합니다. assertTimeoutPreemptively 는 독립적인 스레드로 실행하는데, 트랜잭션이 포함되어 있는 경우 트랜잭션 스레드와는 별개로 수행되어서 롤백이 안되는 경우가 생길 수 있습니다.오래 걸리는 작업인데, 결과값의 검증이 필요한 경우 assertTimeoutPreemptively 보다는 assertTimeout 을 사용하는 것이 낫습니다.\n무조건 사용을 안할 수는 없겠지만, 익셉션이 발생할 수도 있는 통신에 대한 환경 테스트가 필요한 경우 (e.g. 테스트 환경에서 특정 외부 API가 네트워크 접속이 되는지와 같은 테스트 전제 조건을 체크해야 할 경우) 에는 사용할수도 있는 아주 드문 케이스 중 하나입니다."}},"/unit-test/junit-jupiter":{"title":"Junit Jupiter","data":{"junit-jupiter#JUnit Jupiter":""}},"/unit-test/assumption":{"title":"Assumption","data":{"assumption-junit-jupiter#Assumption (Junit Jupiter)":""}},"/unit-test/assertj-assertions":{"title":"Assertj Assertions","data":{"assertions-assertj#Assertions (Assertj)":""}},"/unit-test/what-is-unit-test":{"title":"What Is Unit Test","data":{"단위-테스트의-개념-원칙-목적#단위 테스트의 개념, 원칙, 목적":"","단위테스트란#단위테스트란?":"참고 : ko.wikipedia.org/wiki - 유닛테스트\n단위 테스트는 단위테스트 또는 유닛테스트라고 불립니다. ko.wikipedia.org/wiki - 유닛테스트 에서는 아래와 같이 단위테스트를 설명하고 있습니다.\n컴퓨터 프로그래밍에서 소스 코드의 특정 모듈이 의도된 대로 정확히 작동하는지 검증하는 절차\n즉, 모든 함수와 메소드에 대한 테스트 케이스(Test case)를 작성하는 절차\n이를 통해서 언제라도 코드 변경으로 인해 문제가 발생할 경우, 단시간 내에 이를 파악하고 바로 잡을 수 있는 것이 가능해짐\n이상적으로, 각 테스트 케이스는 서로 분리되어야 한다.\n이를 위해 가짜 객체(Mock object)를 생성하는 것도 좋은 방법\n예를 들어 아래와 같은 코드가 있다고 해보겠습니다.\n// ...\r\nprivate final CommentService commentService;\r\nprivate final CommentCntService commentCntService;\r\n// ...\r\n\r\nprivate final CleanPlatformFeignClient cleanPlatformClient;\r\n\r\n@Transactional\r\npublic void createComment(CommentCreateRequest request){\r\n    // ...\r\n    \r\n    // 1) \r\n    var response = cleanPlatformClient.fetchApi(url, payload);\r\n    \r\n    // 2)\r\n    if(response.isOk()){\r\n        // 3)\r\n        commentService.save(request);\r\n        \r\n        // 4)\r\n        commentCntService.save(request);\r\n    }\r\n    else{\r\n        throw new BadCommentCreateTryException(request);\r\n    }\r\n    \r\n}\n단위테스트는 위 코드에서 1), 2), 3), 4) 메서드 각각에 대한 테스트 케이스들을 만드는 것을 의미합니다. 그리고 1), 2), 3), 4) 내에도 세부적인 메서드 콜이 있다면 그 메서드가 수행하는 동작에 대한 단위 기능에 대한 테스트 케이스를 작성합니다.이때 하나의 단위 기능에서 여러가지 역할을 수행한다면 단위테스트가 모호해집니다. 단위 테스트 기반으로 코드를 작성하게 되면, 하나의 기능은 하나의 역할을 한다, 하나의 기능이 변경되는 이유는 하나의 이유로 변경되어야 한다는 SRP 원칙을 지킨 코드가 되도록 작성하기 수월해지게 됩니다.1) 의 코드는 Mocking 기반으로 실행해야 합니다. 외부 API의 경우에는 외부 API 내부의 요건에 따라 항상 같은 값을 돌려받을 수 있다는 보장이 없기에 테스트 코드에서는 Mocking 기반으로 작성해야 합니다.","first-원칙#FIRST 원칙":"클린 코드의 저자 Robert Martin 이 제시하는 규칙입니다. 효과적인 테스트를 위한 5가지 원칙을 제시하는데, 아래와 같습니다.\nF : Fast\nI : Isolated (or Independent)\nR : Repeatable\nS : Self-Validating\nT : Timely\nF : Fast단위 테스트는 빠르게 실행되어야 한다는 원칙입니다.단위 테스트는 여러가지 경우에 대해 다양한 경우를 테스트하기에 테스트의 속도가 빠를 수록 개발자들이 더 자주 테스트를 실행해서 코드를 수정하고 피드백을 받을 수 있도록 돕습니다.I : Isolated (or Independent)단위 테스트는 독립적으로 수행되어야 합니다. 하나의 테스트가 다른 테스트에 영향을 주지 않고 독립적으로 실행될 수 있어야 합니다.외부 API 호출, 메시지 큐 데이터 Consumer 동작은 단위테스트 코드 내에서는 Mocking 을 기반으로 작성해야 합니다.R : Repeatable단위테스트는 어떤 환경에서도 반복실행을 하더라도 같은 입력값에 대해 같은 결과값을 리턴해야 합니다. 이렇게 같은 입력에 대해 같은 결과값을 리턴하면 테스트가 신뢰할 수 있고 안정적으로 실행될 수 있음을 보장할 수 있게 됩니다.S : Self-validating단위 테스트는 수동으로 결과를 확인할 필요 없이 자동으로 실행될 수 있어야 하며, 테스트의 성공, 실패 여부를 테스트 코드 자체를 통해서 명확히 판단이 가능해야 합니다.또한 결과가 애매한 상황이 없어야 합니다.T : Timely테스트는 적절한 시점에 작성되어야 합니다. 코드의 변경사항이 발생하면, 테스트 코드도 함께 변경해서 일관된 상태를 유지하게끔 해야 합니다. 이렇게 항상 일관된 상태를 유지하게끔 하면 신뢰성, 유지보수성이 향상되게 됩니다."}},"/what-is-software-test":{"title":"What Is Software Test","data":{"소프트웨어-테스트란#소프트웨어 테스트란?":"참고 : ko.wikipedia.org/wiki - 소프트웨어 테스트\n소프트웨어 테스트는 주요 이해관계자들에게 시험 대상 제품, 서비스 품질에 대한 정보를 제공하는 조사과정입니다.소프트웨어 테스트는 아래의 특징들을 제공합니다.\n소프트웨어에 대한 객관적이고 독립적인 시각을 제공\n사업 주체가 소프트웨어 구현의 위험성을 올바로 이해할 수 있도록 도움을 제공","소프트웨어-테스트의-7가지-원칙#소프트웨어 테스트의 7가지 원칙":"참고: ISTQB Foundation Level - Seven testing Principles\nISTQB 에서 정의하는 소프트웨어의 7가지 원칙은 아래와 같습니다.\nTesting shows the presence of defects, not their absence\n테스트는 결함의 부재가 아닌, 결함의 존재를 보여줘야 합니다.\n테스트를 통해 소프트웨어의 결함을 확인할 수 있습니다.\nExhaustive testing is impossible\n완벽한 테스트는 불가능합니다.\nEarly testing saves time and money\n일찍 진행한 테스트는 비용을 줄여줍니다.\nDefects cluster together\n결함은 집중되고 군집(클러스터)되는 경향이 있습니다.\nBeware of the pesticide paradox\n살충제 패러독스에 빠지지 않도록 해야합니다.\nTesting is context-dependent\n테스트는 주변 환경에 의존적입니다.\nAbsence-of-errors is a fallacy\n오류가 없다는 것은 오류입니다.","testing-shows-the-presence-of-defects-not-their-absence#Testing shows the presence of defects, not their absence":"테스트는 결함의 부재가 아닌, 결함의 존재를 보여줘야 합니다.\n테스트를 통해 소프트웨어의 결함을 확인할 수 있다.\n테스트는 소프트웨어의 결함을 찾기 위한 과정이며, 소프트웨어에 결함이 있다는 것을 보여주는 과정입니다. 테스트는 결함을 찾아가는 과정이며, 완전하게 오류가 없음을 보장하지는 않습니다. 다만 일정 수준의 테스트를 통해서 소프트웨어의 정상 작동 범위를 보장할 수 있고 신뢰성을 높일 수 있습니다.","exhaustive-testing-is-impossible#Exhaustive testing is impossible":"완벽한 테스트는 불가능합니다.\n모든 입력, 전제조건들을 일일이 테스트하는 것은 실제로는 불가능합니다. 테스트에 필요한 인적, 시간적 리소스는 한정적입니다. 따라서 필요한 기능과 정합성이 보장되어야 하는 요소를 적절하게 선정해서 테스트를 적용해야 합니다.","early-testing-saves-time-and-money#Early testing saves time and money":"일찍 진행한 테스트는 비용을 줄여줍니다.\n테스트는 일찍 진행할 수록 비용이 줄어듭니다. 요구사항 수립, 개발작업 사이에 먼저 테스트를 통해 발견한 버그는 QA 시에 발생하는 시간적, 인적 리소스를 줄여줍니다.","defects-cluster-together#Defects cluster together":"결함은 집중되고 군집(클러스터)되는 경향이 있습니다.\n결함은 특정 요소에 클러스터처럼 퍼져있는 경우가 많습니다.","beware-of-the-pesticide-paradox#Beware of the pesticide paradox":"살충제 패러독스에 빠지지 않도록 해야합니다.\n시간이 지남에 따라 동일한 테스트 케이스를 반복해서 수행하는 것은 지양해야 합니다. 동일한 테스트를 반복하면, 소프트웨어가 정상적으로 수행되는 것은 확인이 가능하지만, 새로운 문제는 발견해내지 못합니다.테스트를 정기적으로 업데이트하고 검토하면서 테스트를 개선시켜나가야 합니다.","testing-is-context-dependent#Testing is context-dependent":"테스트는 주변 환경에 의존적입니다.\n테스트는 주변 환경에 따라서 완전히 달라질 수 있습니다. 프로젝트 마다 요구되는 주변 상황, 환경 등을 고려해서 테스트의 환경을 커스터마이징해야 합니다. 예를 들면 증권 시세 데이터서비스와 원장 서비스는 환경이 다릅니다. 각각의 환경에 맞는 테스트 환경을 수립해야 합니다.","absence-of-errors-is-a-fallacy#Absence-of-errors is a fallacy":"오류가 없다는 것은 오류입니다.\n소프트웨어에 결함이 없다는 것이 단순히 소프트웨어에 결함이 없다는 것을 보장하지는 않습니다. 테스트의 목표를 100% 결함을 찾아내는 것에 목적을 두기보다 사용자에게 제공되는 기능이 올바른지를 검증하는 데에 목적을 두어야 합니다.","테스트의-목적#테스트의 목적":"테스트의 장점은 버그를 검증하거나, 특정 조건 내에서 이 기능이 꼭 성공함을 보장한다거나 특정 기능의 명세는 이런 요구사항을 가짐을 명세화할 경우 테스트는 장점을 가집니다. 완벽한 결함 제거 보다는 꼭 성공해야 하는 필수적인 기능에 대해 기능의 검증을 반복해서 자동화 기반으로 검증할 수 있다면 좋습니다.","테스트의-종류#테스트의 종류":"테스트의 종류는 단위테스트, 슬라이스테스트, 통합테스트가 있습니다. 이번 github 페이지에서는 이 내용들을 다룹니다."}},"/unit-test/test-libraries":{"title":"Test Libraries","data":{"다양한-테스트-라이브러리#다양한 테스트 라이브러리":"JUnit5\nJUnit 5 User Guide\nAssertion, Assumption 라이브러리\nAssertJ\nJUnit5 Assertions\nJUnit5 Assumptions\nHamcrest\nTruth\nMockito Framework\nTestContainers"}}}