{"/":{"title":"Introduction","data":{"":"JUnit Jupiter 기반 단위테스트\nMockito 기반 다양한 단위테스트\nSpring Reactive 에서의 테스트\n슬라이스 테스트 (Web, Data)\n통합 테스트"}},"/integration-test":{"title":"Integration Test","data":{"통합-테스트-integration-test#통합 테스트 (Integration Test)":""}},"/mockito-test":{"title":"Mockito Test","data":{"mockito-테스트#Mockito 테스트":""}},"/reactor-test":{"title":"Reactor Test","data":{"reactor-테스트#Reactor 테스트":""}},"/reactor-test/if-without-stepverifier":{"title":"If without Stepverifier","data":{"stepverifier-없이-테스트할-경우#StepVerifier 없이 테스트할 경우":"StepVerifier 없이 테스트할 경우의 단점들에 대해 알아봅니다.","1-데이터를-즉시-로딩하는-테스트#1) 데이터를 즉시 로딩하는 테스트":"@Test\r\npublic void TEST_FLUX_1_BY_TO_LIST_BLOCK(){\r\n    Flux<Integer> numbers = Flux.create(sink -> {\r\n      for(int i=0; i<10; i++) sink.next(i);\r\n      sink.complete();\r\n    });\r\n\r\n    var expectedList = IntStream.range(0, 10)\r\n        .boxed()\r\n        .collect(Collectors.toList());\r\n\r\n    var actualList = numbers.collectList().block();\r\n\r\n    Assertions.assertIterableEquals(expectedList, actualList);\r\n}\nStream 과 Iterable 의 차이점, 단점 등에서 자주 언급되듯, Iterable 은 모든 데이터를 한번에 전달해줍니다. 반면 Stream 은 데이터를 게으르게 전달해주며, 한번에 데이터를 모아서 전달해주는 방식이 아닙니다. Flux 역시도 데이터를 한번에 모아서 Publish 하는 Publisher 가 아닙니다.따라서 위의 코드 처럼 Flux 를 Iterable 로 변환해서 테스트하는 것은 비효율적입니다. 틀린 코드는 아니지만 Flux 의 장점을 활용하지 못한 코드입니다.","2-예외-발생-직전의-요건을-테스트하기-쉽지-않다#2) 예외 발생 직전의 요건을 테스트하기 쉽지 않다":"@Test\r\npublic void TEST_FLUX_2_THROW_EXCEPTION_STATEMENT(){\r\n    Flux<Integer> numbers = Flux.create(sink -> {\r\n      for(int i=0; i<10; i++) {\r\n        sink.next(i);\r\n        if(i==5) sink.error(new RuntimeException(\"잠깐 멈춰봐요\"));\r\n      }\r\n      sink.complete();\r\n    });\r\n\r\n    Assertions.assertThrows(RuntimeException.class, () -> {\r\n      numbers.collectList().block();\r\n    });\r\n}\ni=5 일 때 RuntimeException 을 내고 있습니다. 만약 RuntimeException 이 발생하기 전에 i=4 일때 어떤 값이 있었는지, 어떤 데이터였는지 요건을 파악하고 싶다면 어떻게 해야 할까요?  테스트를 위해서 Flux 의 바깥에 조건변수를 두거나 여러가지 제어 구문을 적용해야만 할 것입니다.위의 코드는 정상적인 코드이지만, Webflux 의 StepVerifier 를 활용한다면 조금 더 유연한 테스트가 가능해집니다.","3-delay-및-timeout-이-적용된-코드-테스트시-어려움#3) Delay 및 Timeout 이 적용된 코드 테스트시 어려움":"@Test\r\npublic void TEST_FLUX_3_HEAVY_JOB_TEST(){\r\n    Flux<Integer> numbers = Flux.range(0, 10)\r\n        .delayElements(Duration.ofSeconds(2));\r\n\r\n    var expectedList = IntStream.range(0, 10)\r\n        .boxed()\r\n        .collect(Collectors.toList());\r\n\r\n    var actualList = numbers.collectList().block();\r\n\r\n    Assertions.assertIterableEquals(expectedList, actualList);\r\n}\n한 개의 요소를 순회할 때마다 2초가 걸리며 10개의 요소를 순회합니다. 이렇게 되면 테스트 시에 20초의 시간이 소요됩니다. 이렇게 되면 테스트의 FIRST 원칙 중 F (Fast) 원칙을 위배하게 됩니다.어떤 로직이 10분마다 한번씩 실행되는지를 테스트해보고 싶은 경우에는 어떻게 해야할까요? 또는 어떤 메일 발송 로직이 1일마다 한번씩 실행됨을 보장하려면 어떻게 해야 할까요? StepVerifier 의 withVirtualTime 을 사용하면 이런 테스트에 대해서 유연하게 대응이 가능해집니다.하지만, 알아둬야 할 것이 하나 있습니다. 실제 Publisher 를 생성해서 return 하는 Supplier 람다를 withVirtualTime() 내부에서 선언해야만 VirtualTimeScheduler 기반의 테스트가 가능하다는 점입니다."}},"/reactor-test/stepverifier-test":{"title":"Stepverifier Test","data":{"stepverifier-테스트#StepVerifier 테스트":"StepVerifier 를 기반으로 테스트를 수행하면 Publisher 를 다양한 방식들로 활용해서 여러가지 이벤트를 활용해서 검증이 가능해집니다.","참고#참고":"https://www.baeldung.com/reactive-streams-step-verifier-test-publisher","실행-방식#실행 방식":"StepVerifier.create(), StepVerifier.withVirtualTime()Publisher 를 생성하는 것은 StepVerifier.create() 또는 StepVerifier.withVirtualTime() 을 통해 생성합니다.FirstStep, Step, LastStepStepVerifier 는 FirstStep, Step, LastStep 으로 구성됩니다.FirstStep\nFirstStep 은 처음 받는 이벤트인 onSubscription 과 관련된 객체입니다.\nStep\nStep 은 이후에 들어오는 이벤트 들을 순차적으로 검증할 때 사용하는 객체입니다.\nLastStep\nLastStep 은 최종 결과를 검증할 때 사용합니다.\n위의 검증이 모두 실패하면 테스트는 실패합니다.StepVerifier 내부의 코드를 보면, create() 메서드는 FirstStep 을 반환한다는 사실을 알 수 있습니다.\nFirstStep 타입(interface) 내에서는 expectSubscription() 메서드의 리턴 값은 Step<T> 을 리턴한다는 사실을 알 수 있습니다. expectSubscription() 을 통해 subscription 을 시작하게 되면 onNext 이벤트가 내부적으로 발생하게 됩니다. 또는 expectSubscription() 을 명시적으로 호출하지 않아도 FirstStep 타입은 Step 타입을 상속하고 있기 때문에 Step 타입내의 expectSubscription() 없이 바로 expectNext() 메서드를 통해 onNext 이벤트를 발생시키는 것이 가능합니다.\nStep 타입(interface) 내에서는 exepectNext() 메서드를 통해 onNext 이벤트를 처리하며, 그 다음 onNext 이벤트 들을 체이닝 방식으로 처리가 가능하도록 Step<T> 을 리턴하고 있다는 사실을 확인 가능합니다.\n다음은 LastStep 입니다. LastStep 에서는 complete(), verifyComplete() 메서드를 제공하고 있습니다.","firststep#FirstStep":"","내부-정의#내부 정의":"StepVerifier 내부의 코드를 보면, StepVerifier 의 create() 메서드는 FirstStep 을 반환한다는 사실을 알 수 있습니다. FirstStep 타입의 객체는 이렇게 StepVerifier 의 create() 메서드를 통해서 생성가능합니다.위의 캡처에서 가장 마지막의 create() 메서드를ㄹ 보면 FirstStep 을 생성 시에는 Subscription 에 전달할 requet 수, StepVerifierOptions 를 인자로 받고 있습니다.StepVerfierOptions 클래스를 이용하면, initialRequest 필드를 이용해서 Subscription 에 전달할 request 수를 지정할 수 있고, withInitialContext 필드를 이용해서 Context 등과 같은 별도의 정보들을 지정하는 것 역시 가능합니다.FirstStep 타입 내에는 expectSubscription() 이라는 메서드가 존재합니다.이 expectSubscription() 메서드는 onSubscribe 이벤트에 대한 테스트 메서드 입니다. expectSubscription 메서드를 호출한 이후부터는 Step 을 이용해서 계속해서 체이닝이 가능해지게 됩니다. FirstStep 은 Step 을 상속하고 있기 때문에 expectSubscriptio() 메서드를호출하지 않고도 바로 다음단계인 Step 으로 넘어가는 것 역시 가능합니다.","eg-expectnext#e.g. expectNext":"Step 에서 테스트해볼 내용이지만, 이번 섹션에서는 단순한 예제를 하나 정리해봅니다.\n@Test\r\npublic void TEST_FIRST_STEP_SIMPLE_1(){\r\n    Flux<Integer> numbers = Flux.range(0, 11);\r\n\r\n    StepVerifier.create(numbers)\r\n        .expectSubscription()\r\n        .expectNext(0,1,2,3,4)  // 1)\r\n        .expectNextCount(3) \t// 2) 실제 값 : 5,6,7\r\n        .expectNext(8,9,10)     // 3) \r\n        .verifyComplete();\r\n}\n1)\nexpectNext 를 통해서 0, 1, 2, 3, 4 의 값을 받습니다. onNext 이벤트가 5번 발생했다는 의미와 같습니다.\n2)\nexpectNextCount 를 통해서 3 개의 요소를 받습니다. expectNextCount(count) 메서드 내에 count 로 명시한 값은 뒤에서 몇개의 값을 onNext로 더 받을지를 의미합니다.\n3)\nexpectNext 를 통해서 8, 9, 10 의 값을 받습니다.","eg-initialrequest#e.g. initialRequest":"테스트하려는 Flux 의 크기를 알 수 없는 경우가 있습니다. 이런 경우 테스트 하려는 Flux 중에서 몇번째 까지만을 테스트할지를 명시할 수 있습니다. 아래 코드 처럼 StepVerifier.create(flux, initialRequestSize) 형태의 StepVerifier.create 메서드를 사용하면 \"Flux 의 맨 처음 요소부터 initialRequestSize 까지를 onSubscribe 이벤트 발생시 읽어들인다\" 라는 의미가 됩니다. 그리고 그 뒤의 요소는 꼭 thenCancel().verify() 등과 같은 종료연산을 통해 종료를 시켜줘야 합니다.\n@Test\r\npublic void TEST_FIRST_STEP_SIMPLE_2(){\r\n    Flux<Integer> numbers = Flux.range(0, 11);\r\n    var initialRequestSize = 3;\r\n\r\n    StepVerifier.create(numbers, initialRequestSize)\r\n        .expectSubscription()\r\n        .expectNext(0, 1, 2).as(\"first\")\r\n        .thenCancel()\r\n        .verify();\r\n\r\n    StepVerifier.create(numbers, initialRequestSize)\r\n        .expectNext(0).as(\"1 of 3\")\r\n        .expectNext(1).as(\"2 of 3\")\r\n        .expectNext(2).as(\"3 of 3\")\r\n        .thenCancel()\r\n        .verify();\r\n}\n그런데 만약 thenCancel().verify() 대신 verifyComplete() 같은 메서드를 사용할 경우 테스트는 멈추지 않고 계속 무한히 수행됩니다. 데이터의 끝을 모르는 채로 StepVerifier 가 Flux 퍼블리셔를 구독하고 있게 되기 때문입니다.","stepverifieroptions#StepVerifierOptions":"FirstStep 을 이용해서 Step 을 생성할 때에는 StepVerifierOptions 를 이용해서 initialRequest 와 같은 옵션을 지정해줄 수 있습니다.\n@Test\r\npublic void TEST_FIRST_STEP_VERIFIER_OPTIONS(){\r\n    // 1)\r\n    StepVerifierOptions option = StepVerifierOptions.create()\r\n        .initialRequest(3)\r\n        .checkUnderRequesting(false)\r\n        .scenarioName(\"simple 2\");\r\n\r\n    Flux<String> message = Flux.just(\"A\",\"B\",\"C\",\"D\",\"E\");\r\n\r\n    // 2)\r\n    StepVerifier\r\n        .create(message, option)\r\n        .expectSubscription()\r\n        .expectNext(\"A\",\"B\",\"C\").as(\"first\")\r\n        .thenRequest(2)\r\n        .expectNextCount(2).as(\"second\")\r\n        .expectComplete()\r\n        .verify();\r\n\r\n    // 3)\r\n    StepVerifier\r\n        .create(message, option)\r\n        .expectSubscription()\r\n        .expectNext(\"A\",\"B\",\"C\").as(\"first\")\r\n        .thenCancel()\r\n        .verify();\r\n}\nStepVerifierOptions 의 initialRequest 를 지정해주면, 데이터의 크기를 알수없는 Flux 에 대해 전체 Flux 를 소모하는 것이 아니라 필요한 부분만을 소모해서 테스트 후 테스트를 종료할 수 있습니다. 실제 서비스 운영시에는 읽어와야 할 데이터의 사이즈를 알수 없는 경우가 많습니다. 이런 경우 필요한 부분까지만 읽어들이고 중지해서 과도한 리소스 소모를 방지합니다.그런데 만약 thenCancel().verify() 대신 verifyComplete() 같은 메서드를 사용할 경우 테스트는 멈추지 않고 계속 무한히 수행됩니다. 데이터의 끝을 모르는 채로 StepVerifier 가 Flux 퍼블리셔를 구독하고 있게 되기 때문입니다.1)\ninitialRequest 에 대해 3개의 요소를 request 하고 있습니다. 이렇게 지정하면 3개의 요소를 onSubscribe 이벤트 발생시에 request 하겠다는 의미입니다.\n2)\nexpectSubscription() 은 생략하고 바로 expectNext(), expectNextCount() 를 사용가능합니다. 다만 onSubscribe 이벤트에 대한 동작을 정의한 Publisher 를 사용중이라면 expectSubscription() 메서드를 꼭 사용해야 올바른 테스트 결과를 얻을 수 있습니다.\ninitialRequest 를 3 으로 지정했기에, 여기에서 5 개의 Flux 내의 item 들 중 3개의 item 들을 처음으로 request 합니다. 그리고 2개가 남아 있는데, 남아있는 2개의 요소는 thenRequest 를 통해 2개의 요소를 request 하고 expectNextCount 구문을 통해 검증을 수행했습니다.\n이렇게 뒤에 남아있는 요소가 있을 때에는 꼭 thenRequest() 또는 thenCancel() 을 통해서 Flux 퍼블리셔를 꼭 종료시켜줘야 합니다.\n3)\ninitialRequest 가 3 인 StepVerifierOptions 를 이용해서 request 했습니다. 이때 첫 subscribe 시 3 개의 요소만 request 한 상태입니다.\n그리고 이 후의 테스트는 데이터의 사이즈가 얼마가 될지 얼마나 클지 확인할수 없는 상황이라고 가정하고 thenCancel() 과 verify() 를 이용해 종료시켜줬습니다.","step#Step":"","step-의-다양한-메서드#Step 의 다양한 메서드":"Step 타입 내에는 as(String description), then(Runnable task), thenRequest(long n) 메서드가 제공됩니다.as(String description)\n이전 step 에 description 을 추가합니다. 테스트 실패시에 as 에 넘겨진 description 이 로그에 나타나게 됩니다.\nthen(Runnable task)\n이전 step 이후(e.g. expectNext, expectNextCount)에 Runnable 코드를 인자로 받아서 실행하는 메서드 입니다.\nthenRequest(long n)\n이전 step 이후(e.g. expectNext, expectNextCount)에 n 만큼의 request 를 수행합니다.\n예제는 위에서 살펴봤던 예제로 대체합니다.e.g.\n@Test\r\npublic void TEST_FIRST_STEP_VERIFIER_OPTIONS(){\r\n    // 1)\r\n    StepVerifierOptions option = StepVerifierOptions.create()\r\n        .initialRequest(3)\r\n        .checkUnderRequesting(false)\r\n        .scenarioName(\"simple 2\");\r\n\r\n    Flux<String> message = Flux.just(\"A\",\"B\",\"C\",\"D\",\"E\");\r\n\r\n    // 2)\r\n    StepVerifier\r\n        .create(message, option)\r\n        .expectSubscription()\r\n        .expectNext(\"A\",\"B\",\"C\").as(\"first\")\r\n        .thenRequest(2)\r\n        .expectNextCount(2).as(\"second\")\r\n        .expectComplete()\r\n        .verify();\r\n\r\n    // 3)\r\n    StepVerifier\r\n        .create(message, option)\r\n        .expectSubscription()\r\n        .expectNext(\"A\",\"B\",\"C\").as(\"first\")\r\n        .thenCancel()\r\n        .verify();\r\n}","onnext#onNext":"StepVerifier 로 테스트를 수행할 때 그 다음 요소들을 검사할 수 있는 메서드를 잘 알고 있어야 테스트 코드 작성이 수월해집니다. 아래는 onNext 이벤트에 대한 기능을 수행하는 Step 내의 메서드 들입니다.\nassertNext : item 의 값을 검증합니다. java 의 Consumer 를 이용해서 assert 문을 수행하는 방식을 ㅗ작성합니다.\nexpectNext : 한개 이상의 item 을 값과 순서를 맞춰서 비교하는 메서드 입니다. 가변 인자를 이용해서 여러개의 값을 받는 것이 가능합니다.\nexpectNextCount (count) : count 에 지정한 수 만큼 onNext 이벤트가 발생하는지를 검증합니다.\nexpectNextSequence : iterable 의 element 들을 onNext 로 전달되는 item 들과 값과 순서를 모두 맞춰 비교합니다.\nexpectNextMatches : onNext 이벤트를 통해 전달된 item 을 비교해서 true/false 를 리턴합니다.\n아래는 예제입니다. 간단하기에 설명은 생략합니다.e.g.\n@Test\r\npublic void TEST_STEP_ON_NEXT_EXAMPLE_1(){\r\n    final Logger log = LoggerFactory.getLogger(WitStepVerifierTest.class);\r\n\r\n    Flux<Integer> numbers = Flux.range(0, 8);\r\n\r\n    StepVerifier.create(numbers)\r\n        .assertNext(number -> {\r\n          Assertions.assertEquals(0, number);\r\n        })\r\n        .expectNext(1,2)\r\n        .expectNextCount(1)  // 3,4,5,6,7 요소 남은 상태.\r\n                                // 5 개의 요소가 남은 상태에서 1개의 onNext 발생하는지 체크. 결과는 true\r\n                                // onNext 1개 소모하게 됨\r\n                                // 4,5,6,7 남음.\r\n        .expectNextSequence(List.of(4,5,6))\r\n        .expectNextMatches(number -> number == 7)\r\n        .expectComplete()\r\n        .verify();\r\n}","context-contextexpectations#Context, ContextExpectations":"StepVerifier 를 이용해서 Flux, Mono 등이 수행되는 퍼블리셔가 수행되는 중인 Context 를 테스트합니다. 코틀린 정리문서 - CoroutineContext 에서도 설명했지만, Context 는 자바의 ThreadLocal 처럼 실행 문맥입니다. 다만 webflux 의 경우 비동기 논블로킹이기 때문에 중간에 실행되는 스레드가 바뀔 수 있습니다. 따라서 Spring Webflux 에서는 ThreadLocal 을 사용이 불가능합니다.webflux 를 이용해서 Publisher 프로그래밍을 작성한다고 하더라도 특정 시점의 실행 문맥에서는 Context 를 통해 값을 공유해야 할 필요가 있습니다. 그렇지 않으면 과도한 flatMap 지옥에 빠질 수 있기 때문입니다.ContextExpectation 은 이러한 Context 를 검증할 때 사용하는 객체입니다.ContextExpectation 에서 제공하는 메서드 들은 아래와 같습니다.\nhasKey(Object key) : Context 내에 특정한 key 가 존재하는지 체크합니다.\nhasSize(int size) : Context 의 size가 특정한 size 가 맞는지 체크합니다.\ncontains(Object key, Object value) : Context 에 특정 key,value 쌍이 존재하는지 체크합니다.\ncontainsAllOf(Context other) : 다른 Context 까지 뒤져서 인자로 전달받은 Map 의 모든 key,value 쌍이 존재하는지 검사합니다.\ncontainsOnly(Context other) : 다른 Context 를 인자로 받아서 이 Context 내의 Key,Value 들이 실제로 현재 Context 내에 모두 존재하는지 검사합니다.\nassertThat(Consumer<Context> consumer) : Consumer 타입의 람다를 통해 Assertion 을 수행합니다.\nmatches(Predicate<Context> predicate) : Context 에 대해 Predicate 를 통해 특정 조건식에 해당하는지 검사를 수행합니다.\nthen() : ContextExpectations 를 종료하고, Step 으로 복귀합니다.\ne.g.\n설명은 생략합니다.\n@Test\r\npublic void CONTEXT_EXAMPLE(){\r\n    // 1)\r\n    Flux<Integer> numbers = Flux.range(0,11);\r\n    StepVerifier.create(numbers)\r\n        .expectNoAccessibleContext()\r\n        .expectNextCount(11)\r\n        .verifyComplete();\r\n\r\n    // 2) Context 를 Flux 에 주입\r\n    Flux<Integer> numbersWithCtx1 = Flux.range(0,11)\r\n        .contextWrite(Context.of(\"Hello\", \"World\"));\r\n    StepVerifier.create(numbersWithCtx1)\r\n        .expectAccessibleContext()\r\n        .contains(\"Hello\", \"World\")\r\n        .then()\r\n        .expectNextCount(11)\r\n        .verifyComplete();\r\n\r\n    // 3) Context 를 StepVerifier 에 주입\r\n    Flux<Integer> numbersWithoutCtx = Flux.range(0,11);\r\n\r\n    var option = StepVerifierOptions.create()\r\n            .withInitialContext(Context.of(\"Hello\", \"World\"));\r\n\r\n    StepVerifier.create(numbersWithoutCtx, option)\r\n        .expectAccessibleContext()\r\n        .contains(\"Hello\", \"World\")\r\n        .then()\r\n        .expectNextCount(11)\r\n        .verifyComplete();\r\n}","laststep#LastStep":"참고 : StepVerifier.java\nLastStep 은 StepVerifier 내에 선언된 내부 interface 이며, 최종 결과를 검증하는 기능들에 많이 쓰입니다.Step<T> 은 LastStep 을 확장(상속)하고 있기에, Step 을 통해서 테스트를 종료시키고 싶을 때 LastStep 의 메서드 들을 호출해서 검증 작업을 마무리합니다.LastStep 에서 제공되는 기능들은 아래와 같습니다.\npublic interface StepVerifier {\r\n    // ...\r\n    \r\n    interface Step<T> extends LastStep {\r\n        // ...\r\n    }\r\n    \r\n\tinterface LastStep {\r\n\t\tStepVerifier consumeErrorWith(Consumer<Throwable> consumer);\r\n\r\n\t\tStepVerifier expectError();\r\n\t\tStepVerifier expectError(Class<? extends Throwable> clazz);\r\n\t\tStepVerifier expectErrorMessage(String errorMessage);\r\n\t\tStepVerifier expectErrorMatches(Predicate<Throwable> predicate);\r\n\t\tStepVerifier expectErrorSatisfies(Consumer<Throwable> assertionConsumer);\r\n\t\tStepVerifier expectTimeout(Duration duration);\r\n\t\tStepVerifier expectComplete();\r\n        \r\n\t\tStepVerifier thenCancel();\r\n\r\n\t\tDuration verifyError();\r\n\t\tDuration verifyError(Class<? extends Throwable> clazz);\r\n\t\tDuration verifyErrorMessage(String errorMessage);\r\n\t\tDuration verifyErrorMatches(Predicate<Throwable> predicate);\r\n\t\tdefault Duration verifyTimeout(Duration duration) {\r\n\t\t\treturn expectTimeout(duration).verify();\r\n\t\t}\r\n        \r\n\t\tDuration verifyErrorSatisfies(Consumer<Throwable> assertionConsumer);\r\n\t\tDuration verifyComplete();\r\n\t}\r\n}","expecterror#expectError**()":"Publisher 가 onError 이벤트를 발생시킬 것으로 보일 때 consumeErrorWith() 또는 expectError**() 메서드를 호출해서 검증을 수행할 수 있습니다.\nconsumeErrorWith() : 전달받은 Consumer 를 이용해서 Consumer 내부에서 검증을 수행합니다.\nexpectError() : onError 이벤트가 전달되었는지 여부를 검증합니다. Class 타입을 전달해서 어떤 타입의 에러가 발생하는지를 검증합니다.\nexpectErrorMessage() : onError 이벤트로 전달된 Error 의 메시지가 원하는 에러 메시지인지 검증합니다.\nexpectErrorMatches() : Exception 에 대한 검증 등을 람다식으로 표현한 Predicate 람다를 이용해서 전달받은 Exception 객체가 올바른지를 검증합니다.\nexpectErrorSatisfies() : consumeErrorWith() 와 동일한 역할을 수행합니다.\npublic interface StepVerifier {\r\n    // ...\r\n    \r\n    interface Step<T> extends LastStep {\r\n        // ...\r\n    }\r\n    \r\n\tinterface LastStep {\r\n\t\tStepVerifier consumeErrorWith(Consumer<Throwable> consumer);\r\n\r\n\t\tStepVerifier expectError();\r\n\t\tStepVerifier expectError(Class<? extends Throwable> clazz);\r\n\t\tStepVerifier expectErrorMessage(String errorMessage);\r\n\t\tStepVerifier expectErrorMatches(Predicate<Throwable> predicate);\r\n\t\tStepVerifier expectErrorSatisfies(Consumer<Throwable> assertionConsumer);\r\n\t\tStepVerifier expectTimeout(Duration duration);\r\n\t\tStepVerifier expectComplete();\r\n        \r\n        // ...\r\n        \r\n\t}\r\n}","eg-expecterror#e.g. expectError**()":"간단한 예제이기에 코드 설명은 건너뛰겠습니다.\n@Test\r\npublic void SIMPLE_EXPECT_ERROR(){\r\n    // 1) 단순 검증\r\n    var errorFlux1 = Flux.error(new IllegalArgumentException());\r\n    StepVerifier.create(errorFlux1)\r\n        .expectError()\r\n        .verify();\r\n\r\n    // 2) 예외 타입 검증\r\n    var errorFlux2 = Flux.error(new IllegalArgumentException());\r\n    StepVerifier.create(errorFlux2)\r\n        .expectError(IllegalArgumentException.class)\r\n        .verify();\r\n\r\n    // 3) 예외 메시지 검증\r\n    String message = \"웁스, 에러에요.\";\r\n    var errorFlux3 = Flux.error(new IllegalArgumentException(message));\r\n    StepVerifier.create(errorFlux3)\r\n        .expectErrorMessage(message)\r\n        .verify();\r\n\r\n    // 4) expectErrorMatches\r\n    String message2 = \"웁스, 에러에요\";\r\n    var errorFlux4 = Flux.error(new IllegalArgumentException(message2));\r\n    StepVerifier.create(errorFlux4)\r\n        .expectErrorMatches(e -> {\r\n          return e instanceof IllegalArgumentException && e.getMessage().equals(message2);\r\n        })\r\n        .verify();\r\n\r\n    // 5) expectErrorSatisfies\r\n    String message3 = \"웁스, 에러네요\";\r\n    var errorFlux5 = Flux.error(new IllegalArgumentException(message3));\r\n    StepVerifier.create(errorFlux5)\r\n        .expectErrorSatisfies(e -> {\r\n          Assertions.assertInstanceOf(IllegalArgumentException.class, e);\r\n          Assertions.assertEquals(message3, e.getMessage());\r\n        })\r\n        .verify();\r\n}","expecttimeout#expectTimeout()":"onNext, onComplete 이벤트가 전달받은 duration 내에 발생하지 않으면 true 로 판단합니다. 특정 duration 이상 소요되는지를 검증합니다.\npublic interface StepVerifier {\r\n    // ...\r\n    \r\n    interface Step<T> extends LastStep {\r\n        // ...\r\n    }\r\n    \r\n\tinterface LastStep {\r\n        // ...\r\n\t\tStepVerifier expectTimeout(Duration duration);\r\n\t}\r\n}","eg-expecttimeout#e.g. expectTimeout()":"//-- expectTimeout\r\n@Test\r\npublic void EXPECT_TIMEOUT_TEST(){\r\n    // 1)\r\n    var publisher1 = Mono.delay(Duration.ofMillis(300));\r\n    StepVerifier.create(publisher1)\r\n        .expectTimeout(Duration.ofMillis(50))\r\n        .verify();\r\n\r\n    // 2) 아래 코드는 에러가 나야 정상인 코드\r\n    //    var publisher2 = Mono.delay(Duration.ofMillis(200));\r\n    //    StepVerifier.create(publisher2)\r\n    //        .expectTimeout(Duration.ofSeconds(1))\r\n    //        .verify();\r\n\r\n    // 3)\r\n    var publisher3 = Flux.range(0, 10)\r\n        .delayElements(Duration.ofMillis(500));\r\n    StepVerifier.create(publisher3)\r\n        .expectTimeout(Duration.ofMillis(100))\r\n        .verify();\r\n}","expectcomplete#expectComplete()":"onComplete 이벤트가 발생함을 검증합니다. verifyComplete() 는 expectComplete(), verify() 메서드를 합친 메서드입니다.\npublic interface StepVerifier {\r\n    // ...\r\n    \r\n    interface Step<T> extends LastStep {\r\n        // ...\r\n    }\r\n    \r\n\tinterface LastStep {\r\n        // ...\r\n        \r\n\t\tStepVerifier expectComplete();\r\n        \r\n        // ...\r\n\t}\r\n}","eg-expectcomplete#e.g. expectComplete()":"@Test\r\npublic void EXPECT_COMPLETE_TEST(){\r\n    // 1)\r\n    var publisher1 = Flux.just(\"Hello\", \"World\", \"Great\");\r\n    StepVerifier.create(publisher1)\r\n        .expectNextCount(3)\r\n        .expectComplete()\r\n        .verify();\r\n\r\n    // 2) 아래 코드는 Exception 이 발생하는 코드에 대해 expectError** 을 하지 않았으므로 에러가 발생합니다.\r\n    //    var publisher2 = Flux.error(new IllegalArgumentException());\r\n    //    StepVerifier.create(publisher2)\r\n    //        .expectComplete()\r\n    //        .verify();\r\n}","thencancel#thenCancel()":"Publisher 를 통해 이벤트를 처리하는 도중에 thenCancel 이벤트를 호춣해서 Subscribe 하는 동작을 cancel 하는 것 역시 가능합니다. Subscription.cancel() 을 호출하는 것과 동일한 동작입니다.\npublic interface StepVerifier {\r\n    // ...\r\n    \r\n    interface Step<T> extends LastStep {\r\n        // ...\r\n    }\r\n    \r\n\tinterface LastStep {\r\n\t\t// ...\r\n        \r\n\t\tStepVerifier thenCancel();\r\n\r\n\t\t// ...\r\n\t}\r\n}","eg-thencancel#e.g. thenCancel()":"@Test\r\npublic void THEN_CANCEL(){\r\n    var publisher = Flux.range(1, Integer.MAX_VALUE)\r\n        .doOnNext(number -> System.out.println(\"안녕하세요\"));\r\n\r\n    StepVerifier.create(publisher)\r\n        .expectNextCount(2)\r\n        .thenCancel()\r\n        .verify();\r\n}","verify#verify...()":"verify() 는 호출되는 시점부터 Publisher 를 검증하는 작업을 시작합니다. onComplete, onError, onCancel 이벤트 발생시 block 이 해제됩니다. 기본적으로는 timeout 없이 계속 기다립니다. 또는 Duration 을 명시해서 특정시간 동안만 block 되게끔 지정하는 것 역시 가능합니다.verify() 가 아닌  verify...() 메서드는 아래와 같은 의미입니다. expect...() 메서드 뒤에 verify() 를 붙이는 것의 축약형식으로 제공되는 메서드 입니다.\nverifyComplete() : expectComplete() + verify()\nverifyError() : expectError() + verify()\nverifyErrorMessages() : expectErrorMessages() + verify()\nverifyErrorMatches() : expectErrorMatches() + verify()\nverifyErrorSatisfies() : expectErrorSatisfies() + verify()\npublic interface StepVerifier {\r\n    // ...\r\n    \r\n    interface Step<T> extends LastStep {\r\n        // ...\r\n    }\r\n    \r\n\tinterface LastStep {\r\n        // ...\r\n\t\tDuration verifyError();\r\n\t\tDuration verifyError(Class<? extends Throwable> clazz);\r\n\t\tDuration verifyErrorMessage(String errorMessage);\r\n\t\tDuration verifyErrorMatches(Predicate<Throwable> predicate);\r\n\t\tdefault Duration verifyTimeout(Duration duration) {\r\n\t\t\treturn expectTimeout(duration).verify();\r\n\t\t}\r\n        \r\n\t\tDuration verifyErrorSatisfies(Consumer<Throwable> assertionConsumer);\r\n\t\tDuration verifyComplete();\r\n\t}\r\n}","eg-verify#e.g. verify**()":"@Test\r\npublic void VERIFY_METHODS(){\r\n    var message = \"안녕하십니까?\";\r\n    var err = new IllegalArgumentException(message);\r\n    StepVerifier.create(Mono.error(err))\r\n        .verifyErrorMessage(message);\r\n\r\n    StepVerifier.create(Mono.just(3000))\r\n        .expectNext(3000)\r\n        .verifyComplete();\r\n\r\n    var mono = Mono.delay(Duration.ofMillis(300));\r\n    StepVerifier.create(mono)\r\n        .verifyTimeout(Duration.ofMillis(100));\r\n}","eg-verify-1#e.g. verify()":"@Test\r\npublic void VERIFY_METHOD(){\r\n    var publisher = Flux.just(\"Hello\", \"World\", \"Great\");\r\n\r\n    StepVerifier.create(publisher)\r\n        .expectNextCount(3)\r\n        .expectComplete()\r\n        .log()\r\n        .verify();\r\n}","verifythenassertthat#verifyThenAssertThat()":"verifyThenAssertThat() 은 verify() 의 작업을 통해 Pubisher 를 검증하는 작업을 blocking 기반으로 모두 수행 후 Assertions 를 반환해서 Publisher 의 이벤트가 종료 후의 검증 작업을 수행할 수 있도록 제공되는 메서드입니다. 언뜻 보기에 verifyThenAssertThat() 이 반환하는 Assertions 객체가 junit 이나 assertj 에서 제공하는 Assertions 로 착각할 수 있습니다. 하지만 Assertions 는 StepVerifier 내에 선언된 내부 interface 타입입니다. 주의가 필요합니다.\npublic interface StepVerifier {\r\n    // ...\r\n    \r\n    interface Step<T> extends LastStep {\r\n        // ...\r\n    }\r\n    \r\n    Assertions verifyThenAssertThat();\r\n    Assertions verifyThenAssertThat(Duration duration);\r\n    \r\n\tinterface LastStep {\r\n        // ...\r\n\t}\r\n    // ...\r\n    \r\n    interface Assertions {\r\n\t\tAssertions hasDroppedElements();\r\n\t\tAssertions hasNotDroppedElements();\r\n\t\tAssertions hasDropped(Object... values);\r\n\t\tAssertions hasDroppedExactly(Object... values);\r\n\t\tAssertions hasDiscardedElements();\r\n\t\tAssertions hasNotDiscardedElements();\r\n\t\tAssertions hasDiscarded(Object... values);\r\n\t\tAssertions hasDiscardedExactly(Object... values);\r\n\t\tAssertions hasDiscardedElementsMatching(Predicate<Collection<Object>> matcher);\r\n\t\tAssertions hasDiscardedElementsSatisfying(Consumer<Collection<Object>> consumer);\r\n\t\tAssertions hasDroppedErrors();\r\n\t\tAssertions hasNotDroppedErrors();\r\n\t\tAssertions hasDroppedErrors(int n);\r\n\t\tAssertions hasDroppedErrorOfType(Class<? extends Throwable> clazz);\r\n\t\tAssertions hasDroppedErrorMatching(Predicate<Throwable> matcher);\r\n\t\tAssertions hasDroppedErrorWithMessage(String message);\r\n\t\tAssertions hasDroppedErrorWithMessageContaining(String messagePart);\r\n\t\tAssertions hasDroppedErrorsSatisfying(Consumer<Collection<Throwable>> errorsConsumer);\r\n\t\tAssertions hasDroppedErrorsMatching(Predicate<Collection<Throwable>> errorsConsumer);\r\n\t\tAssertions hasOperatorErrors();\r\n\t\tAssertions hasOperatorErrors(int n);\r\n\t\tAssertions hasOperatorErrorOfType(Class<? extends Throwable> clazz);\r\n\t\tAssertions hasOperatorErrorMatching(Predicate<Throwable> matcher);\r\n\t\tAssertions hasOperatorErrorWithMessage(String message);\r\n\t\tAssertions hasOperatorErrorWithMessageContaining(String messagePart);\r\n\t\tAssertions hasOperatorErrorsSatisfying(Consumer<Collection<Tuple2<Optional<Throwable>, Optional<?>>>> errorsConsumer);\r\n\t\tAssertions hasOperatorErrorsMatching(Predicate<Collection<Tuple2<Optional<Throwable>, Optional<?>>>> errorsConsumer);\r\n\t\tAssertions tookLessThan(Duration d);\r\n\t\tAssertions tookMoreThan(Duration d);\r\n    }\r\n}","eg-verifythenassertthat#e.g. verifyThenAssertThat()":"@Test\r\npublic void VERIFY_THEN_ASSERT_THAT(){\r\n    var delay = Duration.ofSeconds(1);\r\n    StepVerifier.create(Flux.just(\"Hello\", \"World\", \"Great\"))\r\n        .expectNextCount(3)\r\n        .expectComplete()\r\n        .log()\r\n        .verifyThenAssertThat(delay)\r\n        .tookLessThan(delay)\r\n        .hasNotDroppedElements();\r\n}","withvirtualtime#withVirtualTime":"만약 Mono 또는 Flux 와 같은 Publisher 에 delay 가 1시간이 걸려있다면 어떻게  해야 할까요? Flux 가 1000개의 item 을 가질 때 delayElements를 통해 각각의 Element를 수행하는 데에 1분의 delay가 필요한 경우 어떻게 해야 할까요?이 경우 테스트를 위해서 1000분을 기다려야할까요?이런 상황에 대비해서 StepVerifier 는 withVirtualTime() 메서드를 제공해주고 있습니다.\npublic interface StepVerifier {\r\n    // ...\r\n    \r\n\tstatic <T> FirstStep<T> withVirtualTime(Supplier<? extends Publisher<? extends T>> scenarioSupplier) {\r\n\t\treturn withVirtualTime(scenarioSupplier, Long.MAX_VALUE);\r\n\t}\r\n    \r\n\tstatic <T> FirstStep<T> withVirtualTime(Supplier<? extends Publisher<? extends T>> scenarioSupplier,\r\n\t\t\tlong n) {\r\n\t\treturn withVirtualTime(scenarioSupplier, () -> VirtualTimeScheduler.getOrSet(true), n);\r\n\t}\r\n    \r\n    // ...\r\n    \r\n\tstatic <T> FirstStep<T> withVirtualTime(\r\n\t\t\tSupplier<? extends Publisher<? extends T>> scenarioSupplier,\r\n\t\t\tSupplier<? extends VirtualTimeScheduler> vtsLookup,\r\n\t\t\tlong n) {\r\n\t\treturn withVirtualTime(scenarioSupplier, StepVerifierOptions.create()\r\n\t\t\t\t.initialRequest(n)\r\n\t\t\t\t.virtualTimeSchedulerSupplier(vtsLookup));\r\n\t}\r\n\r\n\tstatic <T> FirstStep<T> withVirtualTime(\r\n\t\t\tSupplier<? extends Publisher<? extends T>> scenarioSupplier,\r\n\t\t\tStepVerifierOptions options) {\r\n\r\n\t\tDefaultStepVerifierBuilder.checkPositive(options.getInitialRequest());\r\n\t\tObjects.requireNonNull(scenarioSupplier, \"scenarioSupplier\");\r\n\r\n\t\t//force the default VTS supplier if the provided options doesn't define a VTS supplier.\r\n\t\t//note we make a copy just in case the original options are reused.\r\n\t\tif (options.getVirtualTimeSchedulerSupplier() == null) {\r\n\t\t\toptions = options\r\n\t\t\t\t\t.copy()\r\n\t\t\t\t\t.virtualTimeSchedulerSupplier(() -> VirtualTimeScheduler.getOrSet(true));\r\n\t\t}\r\n\t\treturn DefaultStepVerifierBuilder.newVerifier(options, scenarioSupplier);\r\n\t}\r\n    \r\n    // ...\r\n    \r\n}\nwithVirtualTime() 으로 FirstStep 을 생성하면 일반적인 Scheduler 가 아닌 VirtiualTimeScheduler 를 사용하게 됩니다. VirtualTimeScheduler 는 delay() 와 같은 함수들에 대해 실제로 대기하는 대신 건너뛰는 동작을 수행하게 됩니다.withVirtualTime() 메서드 사용시 우리가 사용할 수 있는 메서드 들은 아래의 2가지가 있습니다.\nthenAwait () : 주어진 시간을 대기합니다. withVirtualTime() 과 함께 사용하면 실제 시간을 기다리는 대신 건너뛰는 동작을 수행합니다.\nexpectNoEvent() : 주어진 시간 동안 이벤트가 발생하지 않기를 기대합니다. 실제 시간을 기다리는 대신 주어진 시간을 건너뛰고 그 동안 이벤트가 발생하지 않기를 기대하는 검증을 수행합니다.","eg-delay-가-걸리는-작업을-물리적인-delay-없이-테스트-수행#e.g. delay 가 걸리는 작업을 물리적인 delay 없이 테스트 수행":"@Test\r\npublic void WITH_VIRTUAL_TIME_DELAY_AND_WAI_1(){\r\n    StepVerifier.withVirtualTime(() -> {\r\n          return Flux.just(\"Hello\", \"World\", \"Great\")\r\n              .delayElements(Duration.ofSeconds(1));\r\n        })\r\n        .thenAwait(Duration.ofSeconds(2))\r\n        .expectNextCount(2)\r\n        .thenAwait(Duration.ofSeconds(1))\r\n        .expectNextCount(1)\r\n        .verifyComplete();\r\n}\n위의 코드는 실제로 수행해보면 물리적으로는 3초가 걸리는 Publisher 를 400ms 안에 수행하는 것을 확인 가능합니다.","eg-delay가-걸리는-작업이어도-외부에서-선언한-flux-는-virtualtime이-적용되지-않음#e.g. delay가 걸리는 작업이어도 외부에서 선언한 Flux 는 virtualTime이 적용되지 않음":"Flux 퍼블리셔를 Supplier 외부에서 생성 후에 전달해주면 virtualTime 을 통한 물리적인 delay 를 건너뛰는 동작이 수행되지 않습니다. 이것은 withVirtualTime() 메서드 내부에서 supplier 를 별도로 감싸는 동작이 있어서 생기는 현상입니다. 이 점에 주의해서 테스트 코드를 작성해야합니다.아래 코드는 3초가 걸립니다.\n@Test\r\npublic void WITH_VIRTUAL_TIME_DELAY_AND_WAI_2(){\r\n    var longDelayPublisher = Flux.just(\"Hello\", \"World\", \"Great\")\r\n        .delayElements(Duration.ofSeconds(1));\r\n\r\n    StepVerifier.withVirtualTime(() -> longDelayPublisher)\r\n        .thenAwait(Duration.ofSeconds(2))\r\n        .expectNextCount(2)\r\n        .thenAwait(Duration.ofSeconds(1))\r\n        .expectNextCount(1)\r\n        .verifyComplete();\r\n}","eg-3일이-걸리는-publisher-테스트#e.g. 3일이 걸리는 Publisher 테스트":"아래 코드는 3일이 걸리는 Publisher 의 테스트를 단 밀리세컨드 안에 완료합니다.\n@Test\r\npublic void WITH_VIRTUAL_TIME_3_DAY_DELAY(){\r\n    StepVerifier\r\n        .withVirtualTime(() -> {\r\n          return Flux.just(\"Hello\", \"World\", \"Great\")\r\n              .delayElements(Duration.ofDays(1));\r\n        })\r\n        .expectSubscription()\r\n        .thenAwait(Duration.ofDays(1))\r\n        .expectNextCount(1)\r\n        .thenAwait(Duration.ofDays(2))\r\n        .expectNextCount(2)\r\n        .verifyComplete();\r\n}","testpublisher#TestPublisher":""}},"/slice-test":{"title":"Slice Test","data":{"슬라이스-테스트-slice-test#슬라이스 테스트 (Slice Test)":""}},"/slice-test/data-mongo-test":{"title":"Data Mongo Test","data":{"datamongotest#@DataMongoTest":"Data Access Layer 는 mongodb client 와 같은 데이터베이스 클라이언트를 통해서 데이터베이스라고 하는 이종의 머신과 통신을 하고 그 결과물을 데이터로 응답합니다. Data Access Layer 계층의 테스트코드에서는 MongoDB Connection 설정이 올바르게 되었는지, MongoDB 와 통신이 잘되는지 테스트 하는 것 외에도 실제 쿼리가 잘 짜여진 것인지 역시 테스트해봅니다.Data Access Layer 에 대한 테스트는 스프링에서 @DataR2dbcTest, @DataRedisTest, @DataMongoTest 애노테이션을 통해서 그 기능을 제공해주고 있습니다.이번 문서에서 살펴볼 것은 @DataMongoTest 입니다.","참고#참고":"flapdoodle-oss/de.flapdoodle.mebed.mongo","service-repository-entity-factory-코드#Service, Repository, Entity, Factory 코드":"세부적인 로직들을 이곳에 모두 적기에는 글이 길어져서 링크로 대체합니다\nhttps://github.com/chagchagchag/example-spring-reactive-test/tree/main/src/main/java/io/chagchagchag/example/reactive_test_example/mongo_book","docker-compose#docker-compose":"이번 테스트에서는 mongodb 테스트를 위해 docker-compose 를 사용합니다.더 자세한 docker-compose 에 대한 내용은 MongoDB Replica Set 환경 구축하기 를 참고해주세요.\nversion: '3.8'\r\nservices:\r\n  mongo:\r\n    image: mongo:6.0.5\r\n    ports:\r\n      - 27017:27017\r\n    environment:\r\n      MONGO_INITDB_DATABASE: foobar\r\n      MONGO_INITDB_ROOT_USERNAME: root\r\n      MONGO_INITDB_ROOT_PASSWORD: 1111\n제 경우에는 docker-compose 를 사용하지 않고 아틀라스에 생성해둔 테스트용도의 Mongodb 를 사용했습니다.","mongodb-접속-설정#MongoDB 접속 설정":"","java-설정#Java 설정":"package io.chagchagchag.example.reactive_test_example;\r\n\r\nimport com.mongodb.reactivestreams.client.MongoClient;\r\nimport com.mongodb.reactivestreams.client.MongoClients;\r\nimport io.chagchagchag.example.reactive_test_example.config.BigDecimalToDecimal128Converter;\r\nimport io.chagchagchag.example.reactive_test_example.config.Decimal128ToBigDecimalConverter;\r\nimport java.util.Arrays;\r\nimport org.springframework.beans.factory.annotation.Value;\r\nimport org.springframework.boot.autoconfigure.mongo.MongoProperties;\r\nimport org.springframework.boot.test.context.TestConfiguration;\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.data.mongodb.ReactiveMongoDatabaseFactory;\r\nimport org.springframework.data.mongodb.ReactiveMongoTransactionManager;\r\nimport org.springframework.data.mongodb.core.ReactiveMongoTemplate;\r\nimport org.springframework.data.mongodb.core.SimpleReactiveMongoDatabaseFactory;\r\nimport org.springframework.data.mongodb.core.convert.MongoConverter;\r\nimport org.springframework.data.mongodb.core.convert.MongoCustomConversions;\r\nimport org.springframework.data.mongodb.repository.config.EnableReactiveMongoRepositories;\r\n\r\n@EnableReactiveMongoRepositories(\r\n    basePackages = {\r\n        \"io.chagchagchag.example.reactive_test_example.mongo_book.repository\"\r\n    },\r\n    reactiveMongoTemplateRef = \"helloworldReactiveMongoTemplate\"\r\n)\r\n@TestConfiguration\r\npublic class TestMongodbConfig {\r\n  @Value(\"${spring.data.mongodb.uri}\")\r\n  private String mongoUri;\r\n\r\n  @Bean\r\n  public MongoClient reactiveMongoClient(){\r\n    return MongoClients.create(mongoUri);\r\n  }\r\n\r\n  @Bean\r\n  public ReactiveMongoTransactionManager transactionManager(\r\n      ReactiveMongoDatabaseFactory databaseFactory\r\n  ){\r\n    return new ReactiveMongoTransactionManager(databaseFactory);\r\n  }\r\n\r\n  @Bean(name = \"helloworldReactiveMongoDatabaseFactory\")\r\n  public SimpleReactiveMongoDatabaseFactory helloworldReactiveMongoDatabaseFactory(\r\n      MongoProperties mongoProperties,\r\n      MongoClient mongoClient\r\n  ){\r\n    final String database = \"helloworld\";\r\n    return new SimpleReactiveMongoDatabaseFactory(mongoClient, database);\r\n  }\r\n\r\n  @Bean(name = \"helloworldReactiveMongoTemplate\")\r\n  public ReactiveMongoTemplate helloworldReactiveMongoTemplate(\r\n      ReactiveMongoDatabaseFactory helloworldReactiveMongoDatabaseFactory,\r\n      MongoConverter mongoConverter\r\n  ){\r\n    return new ReactiveMongoTemplate(helloworldReactiveMongoDatabaseFactory, mongoConverter);\r\n  }\r\n\r\n  @Bean\r\n  public MongoCustomConversions mongoCustomConversions(){\r\n    return new MongoCustomConversions(\r\n        Arrays.asList(\r\n            new BigDecimalToDecimal128Converter(),\r\n            new Decimal128ToBigDecimalConverter()\r\n        )\r\n    );\r\n  }\r\n}","srctestresourcesapplication-test-mongodbyml#src/test/resources/application-test-mongodb.yml":"spring:\r\n  data:\r\n    mongodb:\r\n      uri: mongodb+srv://[계정명]:[비밀번호]@[도메인]/","테스트-코드#테스트 코드":"package io.chagchagchag.example.reactive_test_example.slice_test.data_mongo_test;\r\n\r\nimport io.chagchagchag.example.reactive_test_example.TestMongodbConfig;\r\nimport io.chagchagchag.example.reactive_test_example.mongo_book.BookDocumentService;\r\nimport io.chagchagchag.example.reactive_test_example.mongo_book.repository.BookDocumentRepository;\r\nimport io.chagchagchag.example.reactive_test_example.mongo_book.repository.BookDocumentTransactionRepository;\r\nimport io.chagchagchag.example.reactive_test_example.mongo_book.repository.entity.BookDocument;\r\nimport io.chagchagchag.example.reactive_test_example.mongo_book.repository.factory.BookDocumentFactory;\r\nimport java.math.BigDecimal;\r\nimport java.util.List;\r\nimport java.util.stream.Collectors;\r\nimport org.junit.jupiter.api.DisplayName;\r\nimport org.junit.jupiter.api.Test;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.boot.test.autoconfigure.data.mongo.DataMongoTest;\r\nimport org.springframework.test.context.ActiveProfiles;\r\nimport org.springframework.test.context.ContextConfiguration;\r\n\r\n@ActiveProfiles(\"test-mongodb\")\r\n@ContextConfiguration(\r\n    classes = {\r\n        TestMongodbConfig.class,\r\n        BookDocumentService.class,\r\n        BookDocumentRepository.class,\r\n        BookDocumentTransactionRepository.class,\r\n        BookDocumentFactory.class,\r\n    }\r\n)\r\n@DataMongoTest\r\npublic class DataMongoTest_Example1 {\r\n\r\n  private static Logger log = LoggerFactory.getLogger(DataMongoTest_Example1.class);\r\n\r\n  @Autowired\r\n  private BookDocumentService sut;\r\n\r\n  @DisplayName(\"TEST_새로운_책을_트랜잭셔널_애노테이션을_이용해_저장_및_수정\")\r\n  @Test\r\n  public void TEST_새로운_책을_트랜잭셔널_애노테이션을_이용해_저장_및_수정(){\r\n    // given\r\n\r\n    // when\r\n\r\n    // then\r\n    log.info(\"before save\");\r\n    List<BookDocument> result = sut.insertNewBook(\"맛도리 여행\", BigDecimal.valueOf(3000))\r\n        .toStream()\r\n        .collect(Collectors.toList());\r\n    log.info(\"after save, result = {}\", result);\r\n  }\r\n\r\n}","testcontainers-기반-테스트#Testcontainers 기반 테스트":"몇일 내로 정리 예정입니다. 다른 작업도 밀려있어서 잠시 스킵합니다.","embedded-mongodb-테스트#embedded mongodb 테스트":"docker compose 등으로 설치하는 몽고디비가 무겁다고 느낄 경우 테스트환경에서는 아래와 같이 de.flapdoodle.embed.mongo 를 사용가능합니다.\n개인적으로는 embedded mongodb 를 설정하느라 힘들어할 바에야 testcontainer 를 이용해서 docker-compose 으로 테스트를 진행하는 것도 나쁘지 않고 효율적이라고 생각합니다.","의존성-추가#의존성 추가":"dependencies {\r\n    // ... \r\n\ttestImplementation(\"de.flapdoodle.embed:de.flapdoodle.embed.mongo:4.12.6\")\r\n    // ...\r\n}","#":"embedded mongodb 에 관련해서는 여러가지 충돌나는 부분이 많기에 조금더 자료를 조사해본 후에 정리를 진행해보도록 하겠습니다."}},"/slice-test/web-flux-test":{"title":"Web Flux Test","data":{"webfluxtest#@WebFluxTest":"Controller 는 주어진 API 에 대해 비즈니스 요구사항에 맞는 요청, 응답을 해야 합니다. 예를 들어 어떤 데이터를 조회하려고 하는데 조회하려는 사용자가 권한이 없을 경우 응답코드를 401 로 내려줄수도 있고, 내부에서 정한 응답코드 형식이 따로 있어서 4001 과 같은 코드로 내려주는 경우도 있습니다. Controller 에서는 이렇게 요청,응답의 구조에 대한 형식, 파라미터 검증 등과 같은 역할을 수행합니다.이 외에도 예외처리를 하는 경우도 있습니다. Controller 는 Spring 뿐만 아니라 flask, django 같은 다른 언어의 대중적인 프레임워크에서도 제공합니다. 보통 Spring 에서는 대부분 ControllerAdvice 라는 기능을 통해서 예외 발생시, Exception 에 대해 어떤 Response 내보낼지를 정의합니다.이렇게 요청, 응답, 예외 처리만 하는 것 외에도 Netty, Tomcat 컨테이너 위에서 잘 구동되는지도 확인을 해야 합니다. 따라서 단순한 요청,응답,예외 처리 외에도 WAS 레벨의 테스트까지 수행합니다.@WebFluxTest 는 이렇게 요청,응답,예외 처리와 Netty, Tomcat 컨테이너 위에서의 정상동작 여부를 테스트할 때 사용합니다. @WebFluxTest 를 이용해서 테스트 시 접근하는 Controller 계층, 즉, 프리젠테이션 계층을 테스트 할 때에는 내부 비즈니스 로직에 해당하는 Service 로직의 컴포넌트들은 될수 있으면 모두 가짜객체인 Mock 객체를 기반으로 테스트를 진행하는 것이 권장됩니다.","간단한-예제-코드#간단한 예제 코드":"package io.chagchagchag.example.reactive_test_example.slice_test.web_flux_test;\r\n\r\nimport io.chagchagchag.example.reactive_test_example.GlobalHealthCheckTestConfiguration;\r\nimport io.chagchagchag.example.reactive_test_example.healthcheck.HealthcheckController;\r\nimport io.chagchagchag.example.reactive_test_example.healthcheck.HealthcheckService;\r\nimport org.junit.jupiter.api.Test;\r\nimport org.mockito.Mockito;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.boot.test.autoconfigure.web.reactive.WebFluxTest;\r\nimport org.springframework.boot.test.mock.mockito.MockBean;\r\nimport org.springframework.test.context.ContextConfiguration;\r\nimport org.springframework.test.web.reactive.server.WebTestClient;\r\n\r\n@ContextConfiguration(\r\n    classes = GlobalHealthCheckTestConfiguration.class\r\n)\r\n@WebFluxTest(controllers = HealthcheckController.class)\r\npublic class WebfluxTest_HealthcheckController {\r\n  @MockBean\r\n  HealthcheckService healthcheckService;\r\n\r\n  @Autowired\r\n  WebTestClient webTestClient;\r\n\r\n  @Test\r\n  public void TEST_HEALTHCHECK_API_OK(){\r\n    var message = \"OK\";\r\n\r\n    Mockito.when(healthcheckService.ok())\r\n        .thenReturn(message);\r\n\r\n    webTestClient.get()\r\n        .uri(\"/healthcheck/ready\")\r\n        .exchange()\r\n        .expectStatus().isOk()\r\n        .expectBody(String.class)\r\n        .isEqualTo(message);\r\n  }\r\n}","webfluxtest-살펴보기#@WebFluxTest 살펴보기":"@WebFluxTest 애노테이션은 아래와 같이 정의되어 있습니다.\n@Target({ElementType.TYPE})\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@Documented\r\n@Inherited\r\n@BootstrapWith(WebFluxTestContextBootstrapper.class)\r\n@ExtendWith({SpringExtension.class})\r\n@OverrideAutoConfiguration(\r\n  enabled = false\r\n)\r\n@TypeExcludeFilters({WebFluxTypeExcludeFilter.class})\r\n@AutoConfigureCache\r\n@AutoConfigureJson\r\n@AutoConfigureWebFlux\r\n@AutoConfigureWebTestClient\r\n@ImportAutoConfiguration\r\npublic @interface WebFluxTest {\r\n    // ...\r\n}\nSpring Boot 는 Spring Framework 에 비해서 필요한 기능들에 대해서 어느 정도의 최적화된 자동설정을 제공합니다. @WebFluxTest 애노테이션 역시 @Auto- 로 시작하는 애노테이션을 통해 어느 정도의 최적화된 자동설정을 제공합니다.\n@AutoConfigureCache\n@AutoConfigureJson\n@AutoConfigureWebFlux\n@AutoConfigureWebTestClient\n@ImportAutoConfiguration\n주로 프레젠테이션 계층의 애노테이션만 있다는 것을 확인 가능합니다. WebFluxTest 는 이렇게 프레젠테이션 계층의 애노테이션만 활용해서 웹 계층의 테스트를 최적으로 수행할 수 있도록 구성되어 있습니다.위의 코드를 보면 @TypeExcludeFilters({WebFluxTypeExcludeFilter.class}) 가 있습니다. 이것은 테스트 코드 내에서 Exclude 를 하는 필터가 있을 경우 import 하지 않도록 하는 설정입니다."}},"/slice-test/data-r2dbc-test":{"title":"Data R2dbc Test","data":{"datar2dbctest#@DataR2dbcTest":"","data-access-layer-test#Data Access Layer Test":"Data Access Layer 는 R2DBC 와 같은 데이터베이스 클라이언트를 통해서 데이터베이스라고 하는 이종의 머신과 통신을 하고 그 결과물을 데이터로 응답합니다. Data Access Layer 계층의 테스트코드에서는 Database Connection 설정이 올바르게 되었는지, DBMS 와 통신이 잘되는지 테스트 하는 것 외에도 실제 쿼리가 잘 짜여진 것인지 역시 테스트해봅니다.Data Access Layer 에 대한 테스트는 스프링에서 @DataR2dbcTest, @DataRedisTest, @DataMongoTest 애노테이션을 통해서 그 기능을 제공해주고 있습니다.","docker-compose#docker-compose":"이번 테스트에서는 R2dbc 테스트를 위해 mysql 을 사용합니다.\nversion: '3.7'\r\nservices:\r\n  example-mysql:\r\n    image: mysql:5.7.39-debian\r\n    restart: always\r\n    #    command: --lower_case_table_names=1\r\n    container_name: example-mysql\r\n    hostname: example-mysql\r\n    ports:\r\n      - \"23306:3306\"\r\n    environment:\r\n      - MYSQL_USER=user\r\n      - MYSQL_USER_HOST=%\r\n      - MYSQL_PASSWORD=test1357\r\n      - MYSQL_DATABASE=example\r\n      - MYSQL_ROOT_HOST=%\r\n      - MYSQL_ROOT_PASSWORD=test1357\r\n      - TZ=UTC\r\n    command:\r\n      - --character-set-server=utf8mb4\r\n      - --collation-server=utf8mb4_unicode_ci\r\n    volumes:\r\n      - ./init/:/docker-entrypoint-initdb.d/","database-접속-설정#Database 접속 설정":"","java-설정#Java 설정":"만약 Java 코드로 설정을 하는 편이라면 아래와 같이 작성하면 됩니다.\npackage io.chagchagchag.example.reactive_test_example;\r\n\r\n\r\nimport io.asyncer.r2dbc.mysql.MySqlConnectionConfiguration;\r\nimport io.asyncer.r2dbc.mysql.MySqlConnectionFactory;\r\nimport org.springframework.boot.test.context.TestConfiguration;\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.context.annotation.Profile;\r\nimport org.springframework.data.r2dbc.config.EnableR2dbcAuditing;\r\nimport org.springframework.data.r2dbc.core.R2dbcEntityTemplate;\r\nimport org.springframework.data.r2dbc.repository.config.EnableR2dbcRepositories;\r\nimport org.springframework.r2dbc.connection.R2dbcTransactionManager;\r\nimport org.springframework.r2dbc.connection.init.ConnectionFactoryInitializer;\r\nimport org.springframework.r2dbc.connection.init.ResourceDatabasePopulator;\r\nimport org.springframework.transaction.ReactiveTransactionManager;\r\n\r\n@Profile(\"test-mysql\")\r\n@EnableR2dbcAuditing\r\n@EnableR2dbcRepositories(\r\n    basePackages = \"io.chagchagchag.example.reactive_test_example.healthcheck.repository\"\r\n)\r\n@TestConfiguration\r\npublic class TestMysqlR2dbcConfig {\r\n\r\n  @Bean\r\n  public MySqlConnectionFactory mySqlConnectionFactory(){\r\n    MySqlConnectionConfiguration config = MySqlConnectionConfiguration.builder()\r\n        .host(\"localhost\")\r\n        .port(23306)\r\n        .username(\"user\").password(\"test1357\")\r\n        .database(\"example\")\r\n        .build();\r\n\r\n    return MySqlConnectionFactory.from(config);\r\n  }\r\n\r\n  @Bean\r\n  public ReactiveTransactionManager transactionManager(MySqlConnectionFactory connectionFactory){\r\n    return new R2dbcTransactionManager(connectionFactory);\r\n  }\r\n\r\n  @Bean\r\n  public ConnectionFactoryInitializer initializer(MySqlConnectionFactory connectionFactory){\r\n    ConnectionFactoryInitializer initializer = new ConnectionFactoryInitializer();\r\n    initializer.setConnectionFactory(connectionFactory);\r\n    ResourceDatabasePopulator populator = new ResourceDatabasePopulator();\r\n    initializer.setDatabasePopulator(populator);\r\n    return initializer;\r\n  }\r\n\r\n  @Bean\r\n  public R2dbcEntityTemplate r2dbcEntityTemplate(MySqlConnectionFactory connectionFactory){\r\n    return new R2dbcEntityTemplate(connectionFactory);\r\n  }\r\n}","yml-설정#yml 설정":"제 경우에는 아래 코드를 주석처리해줬습니다. application-test-mysql.yml\nspring:\r\n  r2dbc:\r\n    username: user\r\n    password: test1357\r\n    url: r2dbc:mysql://localhost:23306/example","간단한-테스트-코드#간단한 테스트 코드":"package io.chagchagchag.example.reactive_test_example.slice_test.data_r2dbc_test;\r\n\r\nimport io.chagchagchag.example.reactive_test_example.TestMysqlR2dbcConfig;\r\nimport io.chagchagchag.example.reactive_test_example.healthcheck.repository.BookFindRepository;\r\nimport io.chagchagchag.example.reactive_test_example.healthcheck.repository.entity.Book;\r\nimport io.chagchagchag.example.reactive_test_example.healthcheck.repository.factory.BookFactory;\r\nimport java.math.BigDecimal;\r\nimport java.time.LocalDateTime;\r\nimport org.assertj.core.api.Assertions;\r\nimport org.junit.jupiter.api.Test;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.boot.test.autoconfigure.data.r2dbc.DataR2dbcTest;\r\nimport org.springframework.context.annotation.Import;\r\nimport org.springframework.data.r2dbc.core.R2dbcEntityTemplate;\r\nimport org.springframework.test.context.ActiveProfiles;\r\nimport reactor.core.publisher.Mono;\r\nimport reactor.test.StepVerifier;\r\n\r\n@ActiveProfiles(\"test-mysql\")\r\n@Import(TestMysqlR2dbcConfig.class)\r\n@DataR2dbcTest\r\npublic class DataR2dbcTest_Example1 {\r\n  @Autowired\r\n  BookFindRepository bookFindRepository;\r\n\r\n  @Autowired\r\n  R2dbcEntityTemplate r2dbcEntityTemplate;\r\n\r\n  BookFactory bookFactory = new BookFactory();\r\n\r\n  @Test\r\n  public void SAVE_ENTITY_TEST(){\r\n    Book book = bookFactory.newBook(\r\n        \"레버리지\", BigDecimal.valueOf(16200), LocalDateTime.now(), 1L\r\n    );\r\n\r\n    Mono<Book> insertFlux = r2dbcEntityTemplate.insert(book);\r\n\r\n    StepVerifier.create(insertFlux)\r\n        .assertNext(it -> {\r\n          Assertions.assertThat(it.getName()).isEqualTo(book.getName());\r\n          Assertions.assertThat(it.getPrice()).isEqualTo(book.getPrice());\r\n          Assertions.assertThat(it.getPublishedAt()).isEqualTo(book.getPublishedAt());\r\n          Assertions.assertThat(it.getAuthorId()).isEqualTo(book.getAuthorId());\r\n        })\r\n        .verifyComplete();\r\n  }\r\n}"}},"/slice-test/what-is-context-configuration":{"title":"What Is Context Configuration","data":{"contextconfiguration#@ContextConfiguration":"@ContextConfiguration 은 org.springframework.test.context  패키지 내에 정의된 테스트 용도의 컴포넌트 스캔 용도의 애노테이션입니다.@ContextConfiguration 은 테스트 시에 읽어들일 컴포넌트 들을 읽어들일 때 사용하는 테스트 시에 컴포넌트를 스캔하는 용도의 애노테이션입니다. org.springframewor.test.context 라고 하는 test 전용 용도의 패키지에 정의된 애노테이션이기에 테스트 용도로만 사용 가능합니다.ContextConfiguration.java 의 내부 코드는 아래와 같습니다.\npackage org.springframework.test.context;\r\n\r\nimport java.lang.annotation.Documented;\r\nimport java.lang.annotation.ElementType;\r\nimport java.lang.annotation.Inherited;\r\nimport java.lang.annotation.Retention;\r\nimport java.lang.annotation.RetentionPolicy;\r\nimport java.lang.annotation.Target;\r\n\r\nimport org.springframework.context.ApplicationContextInitializer;\r\nimport org.springframework.context.ConfigurableApplicationContext;\r\nimport org.springframework.core.annotation.AliasFor;\r\n\r\n@Target(ElementType.TYPE)\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@Documented\r\n@Inherited\r\npublic @interface ContextConfiguration {\r\n\t@AliasFor(\"locations\")\r\n\tString[] value() default {};\r\n    \r\n\t@AliasFor(\"value\")\r\n\tString[] locations() default {};\r\n\t\r\n    Class<?>[] classes() default {};\r\n\t\r\n    Class<? extends ApplicationContextInitializer<?>>[] initializers() default {};\r\n\t\r\n    boolean inheritLocations() default true;\r\n\t\r\n    boolean inheritInitializers() default true;\r\n\t\r\n    Class<? extends ContextLoader> loader() default ContextLoader.class;\r\n\t\r\n    String name() default \"\";\r\n}\nlocations : xml 설정을 사용할 경우 읽어들이려는 xml 설정 파일이 위치한 경로들을 지정해줍니다.\nclasses : 읽어들일 Java 기반의 Bean 들의 class 타입들을 지정해줍니다.\n@ContextConfiguration 을 이용해서 테스트에서 사용할 컴포넌트들을 읽어들이는 방식은 3종류가 있습니다.\n@SpringBootApplication 스캔\n@SpringBootApplication 으로 지정된 전체 애플리케이션 컴포넌트 스캔을 읽어들이는 방식\n실제 객체를 사용하는 테스트 입니다.\n@Component 선택 후 부분 스캔\n실제 코드의 원하는 Component 들만을 읽어들여서 부분적인 테스트를 수행하는 방식\n실제 객체를 사용하는 테스트 입니다.\n@TestConfiguration 스캔\n테스트 용도로 정의한 @TestConfiguration 기반의 설정 코드를 @ContextConfiguration 애노테이션으로 테스트 코드에 읽어들이는 방식\n테스트 용도로 별도 정의한 객체를 스캔하는 방식입니다.\nDatabase 처럼 테스트의 검증 동작들이 실제 Database에 값의 변경을 가하면 안되는 환경 등에 대해 @TestConfiguration 등을 통해 별도의 가상 환경(testcontainers 등)을 정의해두기도 합니다.","springbootapplication-스캔#@SpringBootApplication 스캔":"@SpringBootApplication 은 전체 애플리케이션을 ComponentScan 을 하는 애노테이션입니다. @ContextConfiguration 에는 이 @SpringBootApplication 애노테이션이 적용된 클래스를 지정해서 전체 애플리케이션의 실제 컴포넌트 들을 로드해서 테스트할 수 있습니다.이 방식을 사용하는 경우는 develop, cbt 와 같은 환경에 대해 WebTestClient, API 테스트 등 통합테스트가 필요한 일부 기능에 대한 테스트가 필요할 때 사용하는 경우가 많습니다.@SpringBootApplication 적용 클래스\npackage io.chagchagchag.example.reactive_test_example;\r\n\r\nimport org.springframework.boot.SpringApplication;\r\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\r\n\r\n@SpringBootApplication\r\npublic class ReactiveTestExampleApplication {\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\tSpringApplication.run(ReactiveTestExampleApplication.class, args);\r\n\t}\r\n\r\n}\nHealthcheckController.java\npackage io.chagchagchag.example.reactive_test_example.healthcheck;\r\n\r\nimport lombok.RequiredArgsConstructor;\r\nimport org.springframework.web.bind.annotation.GetMapping;\r\nimport org.springframework.web.bind.annotation.RestController;\r\nimport reactor.core.publisher.Mono;\r\n\r\n@RequiredArgsConstructor\r\n@RestController\r\npublic class HealthcheckController {\r\n  private final HealthcheckService healthcheckService;\r\n  @GetMapping(\"/healthcheck/ready\")\r\n  public Mono<String> getReady(){\r\n    return Mono.just(healthcheckService.ok());\r\n  }\r\n}\nHealthcheckService.java\npackage io.chagchagchag.example.reactive_test_example.healthcheck;\r\n\r\nimport org.springframework.stereotype.Service;\r\n\r\n@Service\r\npublic class HealthcheckService {\r\n  public String ok(){\r\n    return \"OK\";\r\n  }\r\n}\n테스트 코드위의 코드들을 테스트하는 코드는 아래와 같습니다.\npackage io.chagchagchag.example.reactive_test_example.slice_test.context_configuration.full_scan;\r\n\r\nimport io.chagchagchag.example.reactive_test_example.ReactiveTestExampleApplication;\r\nimport io.chagchagchag.example.reactive_test_example.healthcheck.HealthcheckController;\r\nimport org.junit.jupiter.api.Test;\r\nimport org.junit.jupiter.api.extension.ExtendWith;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.test.context.ContextConfiguration;\r\nimport org.springframework.test.context.junit.jupiter.SpringExtension;\r\nimport reactor.test.StepVerifier;\r\n\r\n@ExtendWith(SpringExtension.class)\r\n@ContextConfiguration(classes = {ReactiveTestExampleApplication.class})\r\npublic class ContextConfigurationTest_Full_Scan {\r\n\r\n  @Autowired\r\n  HealthcheckController healthcheckController;\r\n\r\n  @Test\r\n  public void TEST_HEALTH_CHECK_CONTROLLER_USING_FULL_SCAN(){\r\n    var expected = \"OK\";\r\n    StepVerifier.create(healthcheckController.getReady())\r\n        .expectNext(expected)\r\n        .verifyComplete();\r\n  }\r\n\r\n}\n위의 코드에서 ContextConfiguration 이 적용된 부분은 아래와 같습니다.\n@ContextConfiguration(classes = {ReactiveTestExampleApplication.class})\n@SpringBootApplication 애노테이션이 적용된 ReactiveTestExampleApplication 이라는 클래스를 @ContextConfiguration 으로 로드했습니다.","component-선택-후-부분-스캔#@Component 선택 후 부분 스캔":"실제 코드의 원하는 Component 들만을 읽어들여서 부분적인 테스트를 수행하는 방식\n실제 객체를 사용하는 테스트 입니다.\n@SpringBootApplication 적용 클래스\npackage io.chagchagchag.example.reactive_test_example;\r\n\r\nimport org.springframework.boot.SpringApplication;\r\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\r\n\r\n@SpringBootApplication\r\npublic class ReactiveTestExampleApplication {\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\tSpringApplication.run(ReactiveTestExampleApplication.class, args);\r\n\t}\r\n\r\n}\nHealthcheckController.java\npackage io.chagchagchag.example.reactive_test_example.healthcheck;\r\n\r\nimport lombok.RequiredArgsConstructor;\r\nimport org.springframework.web.bind.annotation.GetMapping;\r\nimport org.springframework.web.bind.annotation.RestController;\r\nimport reactor.core.publisher.Mono;\r\n\r\n@RequiredArgsConstructor\r\n@RestController\r\npublic class HealthcheckController {\r\n  private final HealthcheckService healthcheckService;\r\n  @GetMapping(\"/healthcheck/ready\")\r\n  public Mono<String> getReady(){\r\n    return Mono.just(healthcheckService.ok());\r\n  }\r\n}\nHealthcheckService.java\npackage io.chagchagchag.example.reactive_test_example.healthcheck;\r\n\r\nimport org.springframework.stereotype.Service;\r\n\r\n@Service\r\npublic class HealthcheckService {\r\n  public String ok(){\r\n    return \"OK\";\r\n  }\r\n}\n테스트 코드\npackage io.chagchagchag.example.reactive_test_example.slice_test.context_configuration.partial_component_scan;\r\n\r\nimport io.chagchagchag.example.reactive_test_example.healthcheck.HealthcheckController;\r\nimport io.chagchagchag.example.reactive_test_example.healthcheck.HealthcheckService;\r\nimport org.junit.jupiter.api.Test;\r\nimport org.junit.jupiter.api.extension.ExtendWith;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.test.context.ContextConfiguration;\r\nimport org.springframework.test.context.junit.jupiter.SpringExtension;\r\nimport reactor.test.StepVerifier;\r\n\r\n@ExtendWith(SpringExtension.class)\r\n@ContextConfiguration(classes = {\r\n    HealthcheckController.class,\r\n    HealthcheckService.class,\r\n})\r\npublic class ContextConfigurationTest_Partial_Component_Scan {\r\n  @Autowired\r\n  HealthcheckController healthcheckController;\r\n\r\n  @Test\r\n  public void (){\r\n    var expected = \"OK\";\r\n    StepVerifier.create(healthcheckController.getReady())\r\n        .expectNext(expected)\r\n        .verifyComplete();\r\n  }\r\n}\n위의 코드에서 원하는 컴포넌트 들만을 스캔하는 부분은 아래와 같습니다.\n@ContextConfiguration(classes = {\r\n    HealthcheckController.class,\r\n    HealthcheckService.class,\r\n})\nHealthcheckCotroller.class, HealthcheckService.class 만을 골라서 컴포넌트 스캔을 하고 있습니다.","testconfiguration-스캔#@TestConfiguration 스캔":"테스트 용도로 정의한 @TestConfiguration 기반의 설정 코드를 @ContextConfiguration 애노테이션으로 테스트 코드에 읽어들이는 방식\n테스트 용도로 별도 정의한 객체를 스캔하는 방식입니다.\nDatabase 처럼 테스트의 검증 동작들이 실제 Database에 값의 변경을 가하면 안되는 환경 등에 대해 @TestConfiguration 등을 통해 별도의 가상 환경(testcontainers 등)을 정의해두기도 합니다.\n@SpringBootApplication 적용 클래스\npackage io.chagchagchag.example.reactive_test_example;\r\n\r\nimport org.springframework.boot.SpringApplication;\r\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\r\n\r\n@SpringBootApplication\r\npublic class ReactiveTestExampleApplication {\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\tSpringApplication.run(ReactiveTestExampleApplication.class, args);\r\n\t}\r\n\r\n}\nHealthcheckController.java\npackage io.chagchagchag.example.reactive_test_example.healthcheck;\r\n\r\nimport lombok.RequiredArgsConstructor;\r\nimport org.springframework.web.bind.annotation.GetMapping;\r\nimport org.springframework.web.bind.annotation.RestController;\r\nimport reactor.core.publisher.Mono;\r\n\r\n@RequiredArgsConstructor\r\n@RestController\r\npublic class HealthcheckController {\r\n  private final HealthcheckService healthcheckService;\r\n  @GetMapping(\"/healthcheck/ready\")\r\n  public Mono<String> getReady(){\r\n    return Mono.just(healthcheckService.ok());\r\n  }\r\n}\nHealthcheckService.java\npackage io.chagchagchag.example.reactive_test_example.healthcheck;\r\n\r\nimport org.springframework.stereotype.Service;\r\n\r\n@Service\r\npublic class HealthcheckService {\r\n  public String ok(){\r\n    return \"OK\";\r\n  }\r\n}\n테스트 코드\npackage io.chagchagchag.example.reactive_test_example.slice_test.context_configuration.test_configuration;\r\n\r\nimport io.chagchagchag.example.reactive_test_example.healthcheck.HealthcheckController;\r\nimport org.junit.jupiter.api.Test;\r\nimport org.junit.jupiter.api.extension.ExtendWith;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.test.context.ContextConfiguration;\r\nimport org.springframework.test.context.junit.jupiter.SpringExtension;\r\nimport reactor.test.StepVerifier;\r\n\r\n@ExtendWith(SpringExtension.class)\r\n@ContextConfiguration(\r\n    classes = {\r\n        HealthCheckTestConfiguration.class\r\n    }\r\n)\r\npublic class ContextConfigurationTest_Test_Configuration {\r\n  @Autowired\r\n  private HealthcheckController healthcheckController;\r\n\r\n  @Test\r\n  public void (){\r\n    StepVerifier.create(healthcheckController.getReady())\r\n        .expectNext(\"OK\")\r\n        .verifyComplete();\r\n  }\r\n}\n위의 코드에서 TestConfiguration 설정 코드를 스캔하는 부분은 아래와 같습니다.\n@ContextConfiguration(\r\n    classes = {\r\n        HealthCheckTestConfiguration.class\r\n    }\r\n)"}},"/slice-test/web-test-client":{"title":"Web Test Client","data":{"webtestclient#WebTestClient":"WebTestClient 는 WebClient 를 Test 코드 내에서 사용할 수 있도록 스프링에서 제공하는 클래스입니다. WebTestClient 의 주요 내용을 파악할 때는 아래의 내용들을 위주로 파악하면, 쉽게 까먹지 않고 오래 기억됩니다.\nWebTestClient 객체의 생성은 MockServerSpec 을 이용하고, 세부적으로는 ControllerSpec, RouterSpec 을 통해서 MockServerSpec 을 접근한다. ControllerSpec, RouterSpec 은 모두 MockServerSpec 을 extends 하는 타입이다.\nWebTestClient 클래스 내에는 응답형태를 검증할 수 있는 ResponseSpec 타입을 제공하며 status, header, cookie, body 를 expect 구문을 통해 검증하는 것이 가능하다.\nWebTestClient 에는 bindToController(), bindToRouterFunction(), bindToServer() 등과 같은 static 메서드를 제공한다.\n각 메서드는 ***Spec 타입을 return 한다.\nbindToController() 메서드 : ControllerSpec 을 return\nbindToRouterFunction() 메서드 : RouterFunctionSpec을 return\nbindToServer() 메서드 : Builder 객체를 return\n각각의 ControllerSpec, RouterFunctionSpec 은 WebTestClient interface 내에 정의된 내부 interface 타입이다.\nControllerSpec, RouterFunctionSpec 은 모두 MockServerSpec 이라는 약간은 공통기능을 모아둔 역할을 하는 interface 를 extends (확장)하고 있다. 따라서 ControllerSpec, RouterFunctionSpec 모두 MockServerSpec 이 제공하는 메서드를 그대로 사용 가능하다.\nMockServerSpec 역시 WebTestClient 내부의 interface 타입이다.\nMockServerSpec 에는 configureClient() 라고 하는 Builder 객체를 리턴하는 메서드, build() 라고 하는 WebTestClient 객체를 생성하는 메서드가 있다.\nWebTestClient 가 HTTP 통신을 수행한 응답결과는 ResponseSpec 객체를 통해 돌려받으며 ResponseSpec 객체는 status, header, cookie, body 관련된 expect 구문들을 제공하고 있다.","주요-메서드#주요 메서드":"참고 : WebTestClient\npackage org.springframework.test.web.reactive.server;\r\n// ...\r\npublic interface WebTestClient {\r\n\tString WEBTESTCLIENT_REQUEST_ID = \"WebTestClient-Request-Id\";\r\n\tRequestHeadersUriSpec<?> get();\r\n\tRequestHeadersUriSpec<?> head();\r\n\tRequestBodyUriSpec post();\r\n\tRequestBodyUriSpec put();\r\n\tRequestBodyUriSpec patch();\r\n\tRequestHeadersUriSpec<?> delete();\r\n\tRequestHeadersUriSpec<?> options();\r\n\tRequestBodyUriSpec method(HttpMethod method);\r\n\tBuilder mutate();\r\n\tWebTestClient mutateWith(WebTestClientConfigurer configurer);\r\n\r\n\r\n\t// Static factory methods\r\n\tstatic ControllerSpec bindToController(Object... controllers) {\r\n\t\treturn new DefaultControllerSpec(controllers);\r\n\t}\r\n\r\n\tstatic RouterFunctionSpec bindToRouterFunction(RouterFunction<?> routerFunction) {\r\n\t\treturn new DefaultRouterFunctionSpec(routerFunction);\r\n\t}\r\n\r\n\tstatic MockServerSpec<?> bindToApplicationContext(ApplicationContext applicationContext) {\r\n\t\treturn new ApplicationContextSpec(applicationContext);\r\n\t}\r\n\r\n\tstatic MockServerSpec<?> bindToWebHandler(WebHandler webHandler) {\r\n\t\treturn new DefaultMockServerSpec(webHandler);\r\n\t}\r\n\r\n\tstatic Builder bindToServer() {\r\n\t\treturn new DefaultWebTestClientBuilder();\r\n\t}\r\n\r\n\tstatic Builder bindToServer(ClientHttpConnector connector) {\r\n\t\treturn new DefaultWebTestClientBuilder(connector);\r\n\t}\r\n\r\n\tinterface MockServerSpec<B extends MockServerSpec<B>> {\r\n        // ...\r\n\t}\r\n\r\n\t// ... interface 타입들 정의 (중략) ...\r\n\r\n}\nbindToController(Object... ) : ControllerSpec\ncontroller 에 대한 WebTestClient 객체 생성\nbindToRouterFunction(RouterFunction) : RouterFunctionSpec\nRouterFunction 에 대한 WebTestClient 객체 생성\nbindToApplicationContext(ApplicationContext) : MockServerSpec\nApplicationContext 내의 bean 들을 기반으로 WebTestClient 객체 생성\nbindToWebHandler(WebHandler) : MockServerSpec\nWebHandler 에 대해 WebTestClient 객체 생성\nbindToServer() : Builder\nReactor Netty 애플리케이션(WAS) 에 Reactor Netty Client 로 접속하는 WebTestClient 객체 생성","bindto#bindTo***()":"bindTo***() 메서드는 bindToController(), bindToApplicationContext(), bindToServer() 메서드를 제공합니다.","bindtocontrollerobject---controllerspec#bindToController(Object... ) : ControllerSpec":"bindToController() 메서드는 ControllerSpec 객체를 return 하는 static 메서드 입니다.\npackage org.springframework.test.web.reactive.server;\r\n// ...\r\npublic interface WebTestClient {\r\n    // ...\r\n\r\n\t// Static factory methods\r\n\tstatic ControllerSpec bindToController(Object... controllers) {\r\n\t\treturn new DefaultControllerSpec(controllers);\r\n\t}\r\n\r\n\t// ... interface 타입들 정의 (중략) ...\r\n\r\n}\n테스트하기를 원하는 1개 이상의 Controller 들을 bindToController 의 가변인자로 전달해주면, ControllerSpec 이라는 객체를 생성할 수 있습니다. ControllerSpec 은 MockServerSpec 이라는 객체를 확장한 타입이며, controllerAdvice, contentTypeResolver, corsMappings 등과 관련된 필드들을 주입 받을 수 있는 역할의 객체입니다. 이 ControllerSpec 은 MockSeverSpec 타입을 확장하고 있는데, MockServerSpec 의 configureClient(), build() 메서드를 통해서 최종적으로 WebTestClient 객체를 생성하는 것이 가능해집니다.MockServerSpec, ControllerSpec 타입에 대한 자세한 내용은 뒤에서도 정리하며, 이 글의 도입부에서도 정리해두었습니다.","eg#e.g.":"","bindtoapplicationcontextapplicationcontext--mockserverspec#bindToApplicationContext(ApplicationContext) : MockServerSpec":"bindToApplicationContext(ApplicationContext) 는 MockServerSpec 을 return 하는 static 메서드입니다.\npackage org.springframework.test.web.reactive.server;\r\n// ...\r\n\r\npublic interface WebTestClient {\r\n    // ...\r\n\r\n\t// Static factory methods\r\n\t// ...\r\n\r\n\tstatic MockServerSpec<?> bindToApplicationContext(ApplicationContext applicationContext) {\r\n\t\treturn new ApplicationContextSpec(applicationContext);\r\n\t}\r\n    \r\n    // ...\r\n\r\n\tinterface MockServerSpec<B extends MockServerSpec<B>> {\r\n        // ...\r\n\t}\r\n\r\n\t// ... interface 타입들 정의 (중략) ...\r\n\r\n}\nbindToApplicationContext (ApplicationContext) 메서드가 반환하는 MockServerSpec 객체를 이용하면 configureClient() 메서드로 Builder 객체를 생성하고 , build() 메서드를 이용해서 WebTestClient 객체를 생성하는 것이 가능합니다. MockServerSpec, ControllerSpec 타입에 대한 자세한 내용은 뒤에서도 정리하며, 이 글의 도입부에서도 정리해두었습니다.","eg-1#e.g.":"","bindtoserverclienthttpconnector--builder#bindToServer(ClientHttpConnector) : Builder":"bindToServer(ClientHttpConnector) 는 Builder 객체를 반환합니다. 이 Builder 객체를 잘 활용하면 WebTestClient 객체를 생성하는 것 역시 가능하게 됩니다.\npackage org.springframework.test.web.reactive.server;\r\n// ...\r\npublic interface WebTestClient {\r\n\t// ...\r\n\r\n\tstatic Builder bindToServer(ClientHttpConnector connector) {\r\n\t\treturn new DefaultWebTestClientBuilder(connector);\r\n\t}\r\n\r\n\tinterface MockServerSpec<B extends MockServerSpec<B>> {\r\n        // ...\r\n\t}\r\n\r\n\t// ... interface 타입들 정의 (중략) ...\r\n\r\n}","eg-2#e.g.":"","mockserverspec#MockServerSpec":"참고 : WebTestClient \n위에서 살펴본 메서드인 bindToApplicationContext(ApplicationContext) : MockServerSpec 은 MockServerSpec 타입을 반환하며, MockServerSpec 타입은 WebTestClient 내의 내부 interface 타입입니다.WebTestClient 객체 생성을 위한 공통 기능을 제공하는 공통 interface 역할을 하며, 뒤에서 살펴볼 ControllerSpec 역시 MockServerSpec 을 extends 하는 interface 입니다.\npackage org.springframework.test.web.reactive.server;\r\n// ...\r\n\r\npublic interface WebTestClient {\r\n\t// ...\r\n    \r\n\tinterface MockServerSpec<B extends MockServerSpec<B>> {\r\n\t\t<T extends B> T webFilter(WebFilter... filter);\r\n\t\t<T extends B> T webSessionManager(WebSessionManager sessionManager);\r\n\t\t<T extends B> T apply(MockServerConfigurer configurer);\r\n\t\tBuilder configureClient();\r\n\t\tWebTestClient build();\r\n\t}\r\n\r\n\t// ... interface 타입들 정의 (중략) ...\r\n\r\n}\nMockServerSpec 은 webFilter(), webSessionManager(), apply() 등과 메서드를 통해서 WebFliter 관련 연산, WebSessionManager 관련 연산, MockServerConfigurer 관련 연산을 지원가능합니다. 이 외에도 configureClient() 메서드는 WebTestClient 내의 Builder 객체를 반환하기에, 이 Builder 객체를 통해서 WebTestClient 내에서 필요한 객체들을 조합 가능하게 됩니다.","controllerspec#ControllerSpec":"참고 : WebTestClient \npackage org.springframework.test.web.reactive.server;\r\n\r\n// ...\r\n\r\npublic interface WebTestClient {\r\n    \r\n\t// ...\r\n    \r\n\tinterface ControllerSpec extends MockServerSpec<ControllerSpec> {\r\n\t\tControllerSpec controllerAdvice(Object... controllerAdvice);\r\n\r\n\t\tControllerSpec contentTypeResolver(Consumer<RequestedContentTypeResolverBuilder> consumer);\r\n        \r\n\t\tControllerSpec corsMappings(Consumer<CorsRegistry> consumer);\r\n\r\n\t\tControllerSpec pathMatching(Consumer<PathMatchConfigurer> consumer);\r\n\r\n\t\tControllerSpec argumentResolvers(Consumer<ArgumentResolverConfigurer> configurer);\r\n\r\n\t\tControllerSpec httpMessageCodecs(Consumer<ServerCodecConfigurer> configurer);\r\n\r\n\t\tControllerSpec formatters(Consumer<FormatterRegistry> consumer);\r\n\r\n\t\tControllerSpec validator(Validator validator);\r\n\r\n\t\tControllerSpec viewResolvers(Consumer<ViewResolverRegistry> consumer);\r\n\r\n\t\tControllerSpec blockingExecution(Consumer<BlockingExecutionConfigurer> consumer);\r\n\t}\r\n\r\n\t// ... interface 타입들 정의 (중략) ...\r\n\r\n}\n주로 컨트롤러와 관련된 요소들인 controllerAdvice, contentTypeResolver, corsMapping, pathMatching, argumentResolvers, httpMessageCodec, viewRsolver 등과 관련된 연산 들을 제공한다는 것을 확인 가능합니다.\n위에서 살펴봤던 MockServerSpec 타입을 extends 하고 있기 때문에 MockServerSpec 의 메서드들을 그대로 사용 가능합니다. 예를 들면 configureClient() 메서드를 이용해서 Builder 객체를 생성하고 이 Builder 객체를 통해 필요한 필드들을 모두 설정한 후 build() 메서드를 통해 WebTestClient 객체를 생성하는 것이 가능합니다.","responsespec#ResponseSpec":"참고 : WebTestClient \nWebTestClient 클래스 내에는 응답형태를 검증할 수 있는 ResponseSpec 타입을 제공하며 status, header, cookie, body 를 expect 구문을 통해 검증하는 것이 가능합니다.\npackage org.springframework.test.web.reactive.server;\r\n\r\n// ...\r\n\r\npublic interface WebTestClient {\r\n    \r\n\t// ...\r\n    \r\n\t// ... interface 타입들 정의 (중략) ...\r\n\r\n\tinterface ResponseSpec {\r\n\t\tResponseSpec expectAll(ResponseSpecConsumer... consumers);\r\n\r\n\t\tStatusAssertions expectStatus();\r\n\t\tHeaderAssertions expectHeader();\r\n\t\tCookieAssertions expectCookie();\r\n        \r\n\t\t<B> BodySpec<B, ?> expectBody(Class<B> bodyType);\r\n\t\t<B> BodySpec<B, ?> expectBody(ParameterizedTypeReference<B> bodyType);\r\n        \r\n\t\t<E> ListBodySpec<E> expectBodyList(Class<E> elementType);\r\n\t\t<E> ListBodySpec<E> expectBodyList(ParameterizedTypeReference<E> elementType);\r\n        \r\n\t\tBodyContentSpec expectBody();\r\n        \r\n\t\t<T> FluxExchangeResult<T> returnResult(Class<T> elementClass);\r\n\t\t<T> FluxExchangeResult<T> returnResult(ParameterizedTypeReference<T> elementTypeRef);\r\n        \r\n\t\t@FunctionalInterface\r\n\t\tinterface ResponseSpecConsumer extends Consumer<ResponseSpec> {\r\n\t\t}\r\n\r\n\t}\r\n\r\n}","eg-3#e.g.":"","status#status":"package io.chagchagchag.example.reactive_test_example.slice_test.verification;\r\n\r\nimport io.chagchagchag.example.reactive_test_example.healthcheck.HealthcheckController;\r\nimport io.chagchagchag.example.reactive_test_example.healthcheck.HealthcheckService;\r\nimport org.junit.jupiter.api.Test;\r\nimport org.junit.jupiter.api.extension.ExtendWith;\r\nimport org.mockito.Mockito;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.boot.test.mock.mockito.MockBean;\r\nimport org.springframework.test.context.ContextConfiguration;\r\nimport org.springframework.test.context.junit.jupiter.SpringExtension;\r\nimport org.springframework.test.web.reactive.server.WebTestClient;\r\n\r\n@ExtendWith(SpringExtension.class)\r\n@ContextConfiguration(classes = {\r\n    HealthcheckController.class\r\n})\r\npublic class StatusVerificationTest {\r\n  @MockBean\r\n  private HealthcheckService healthcheckService;\r\n  \r\n  @Autowired\r\n  private HealthcheckController healthcheckController;\r\n\r\n  @Test\r\n  public void TEST_RESPONSE_IS_OK(){\r\n    WebTestClient webTestClient = WebTestClient\r\n        .bindToController(healthcheckController)\r\n        .build();\r\n\r\n    var expected = \"OK\";\r\n    Mockito.when(healthcheckService.ok())\r\n        .thenReturn(\"OK\");\r\n\r\n    webTestClient.get()\r\n        .uri(\"/healthcheck/ready\")\r\n        .exchange()\r\n        .expectStatus()\r\n        .isOk()\r\n        .expectStatus()\r\n        .is2xxSuccessful();\r\n  }\r\n}","header#header":"Controller\npackage io.chagchagchag.example.reactive_test_example.healthcheck;\r\n\r\nimport lombok.RequiredArgsConstructor;\r\nimport org.springframework.http.ResponseEntity;\r\nimport org.springframework.web.bind.annotation.GetMapping;\r\nimport org.springframework.web.bind.annotation.RestController;\r\nimport reactor.core.publisher.Mono;\r\n\r\n@RequiredArgsConstructor\r\n@RestController\r\npublic class HealthcheckController {\r\n  private final HealthcheckService healthcheckService;\r\n  // ...\r\n\r\n  @GetMapping(\"/healthcheck/ready/header\")\r\n  public Mono<ResponseEntity<String>> getReadyWithHeader(){\r\n    return Mono.just(healthcheckService.ok())\r\n        .map(okMessage -> ResponseEntity.ok()\r\n            .header(\"brand\", \"nike\")\r\n            .header(\"category\", \"shoes\")\r\n            .header(\"email\", \"abc@gmail.com\")\r\n            .body(okMessage)\r\n        );\r\n  }\r\n}\n테스트\npackage io.chagchagchag.example.reactive_test_example.slice_test.verification;\r\n\r\nimport io.chagchagchag.example.reactive_test_example.healthcheck.HealthcheckController;\r\nimport io.chagchagchag.example.reactive_test_example.healthcheck.HealthcheckService;\r\nimport org.assertj.core.api.Assertions;\r\nimport org.junit.jupiter.api.Test;\r\nimport org.junit.jupiter.api.extension.ExtendWith;\r\nimport org.mockito.Mockito;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.boot.test.mock.mockito.MockBean;\r\nimport org.springframework.test.context.ContextConfiguration;\r\nimport org.springframework.test.context.junit.jupiter.SpringExtension;\r\nimport org.springframework.test.web.reactive.server.WebTestClient;\r\n\r\n@ExtendWith(SpringExtension.class)\r\n@ContextConfiguration(classes = HealthcheckController.class)\r\npublic class HeaderVerificationTest {\r\n  @MockBean\r\n  private HealthcheckService healthcheckService;\r\n  @Autowired\r\n  private HealthcheckController healthcheckController;\r\n\r\n  @Test\r\n  public void TEST_HEADER(){\r\n    // given\r\n    WebTestClient webTestClient = WebTestClient\r\n        .bindToController(healthcheckController)\r\n        .build();\r\n\r\n    String expected = \"OK\";\r\n\r\n    // when\r\n    Mockito.when(healthcheckService.ok())\r\n        .thenReturn(\"OK\");\r\n\r\n    // then\r\n    webTestClient.get()\r\n        .uri(\"/healthcheck/ready/header\")\r\n        .exchange()\r\n        .expectHeader()\r\n        .contentType(\"text/plain;charset=UTF-8\")\r\n        .expectHeader()\r\n        .exists(\"brand\")\r\n        .expectHeader()\r\n        .value(\"category\", categoryHeaderValue -> {\r\n          Assertions.assertThat(categoryHeaderValue).isEqualTo(\"shoes\");\r\n        })\r\n        .expectHeader()\r\n        .doesNotExist(\"gender\")\r\n        .expectHeader()\r\n        .valueEquals(\"email\", \"abc@gmail.com\");\r\n\r\n  }\r\n}","cookie#cookie":"Controller\npackage io.chagchagchag.example.reactive_test_example.healthcheck;\r\n\r\nimport lombok.RequiredArgsConstructor;\r\nimport org.springframework.http.ResponseCookie;\r\nimport org.springframework.http.ResponseEntity;\r\nimport org.springframework.web.bind.annotation.GetMapping;\r\nimport org.springframework.web.bind.annotation.RestController;\r\nimport org.springframework.web.server.ServerWebExchange;\r\nimport reactor.core.publisher.Mono;\r\n\r\n@RequiredArgsConstructor\r\n@RestController\r\npublic class HealthcheckController {\r\n  private final HealthcheckService healthcheckService;\r\n  \r\n  // ...\r\n  \r\n  @GetMapping(\"/healthcheck/ready/cookie\")\r\n  public Mono<String> getReadyWithCookie(\r\n      ServerWebExchange exchange\r\n  ){\r\n    ResponseCookie cookie = ResponseCookie.from(\"brand\", \"nike\")\r\n        .maxAge(300)\r\n        .domain(\"youtube.com\")\r\n        .httpOnly(true)\r\n        .path(\"/\")\r\n        .sameSite(\"None\")\r\n        .secure(true)\r\n        .build();\r\n\r\n    exchange.getResponse().addCookie(cookie);\r\n    return Mono.just(healthcheckService.ok());\r\n  }\r\n}\n테스트\npackage io.chagchagchag.example.reactive_test_example.slice_test.verification;\r\n\r\n// ...\r\n\r\n@ExtendWith(SpringExtension.class)\r\n@ContextConfiguration(classes = HealthcheckController.class)\r\npublic class CookieVerificationTest {\r\n  @MockBean\r\n  private HealthcheckService healthcheckService;\r\n  @Autowired\r\n  private HealthcheckController healthcheckController;\r\n\r\n  @Test\r\n  public void TEST_COOKIE(){\r\n    // given\r\n    String expected = \"OK\";\r\n    WebTestClient webTestClient = WebTestClient.bindToController(healthcheckController)\r\n        .build();\r\n\r\n    // when\r\n    Mockito.when(healthcheckService.ok())\r\n        .thenReturn(expected);\r\n\r\n    // then\r\n    var cookieName = \"brand\";\r\n    webTestClient.get()\r\n        .uri(\"/healthcheck/ready/cookie\")\r\n        .exchange()\r\n        .expectCookie().exists(cookieName)\r\n        .expectCookie().valueEquals(cookieName, \"nike\")\r\n        .expectCookie().domain(cookieName,\"youtube.com\")\r\n        .expectCookie().httpOnly(cookieName,true)\r\n        .expectCookie().path(cookieName, \"/\")\r\n        .expectCookie().secure(cookieName, true)\r\n        .expectCookie().maxAge(cookieName, Duration.ofSeconds(300));\r\n  }\r\n}","body#body":"Controller\npackage io.chagchagchag.example.reactive_test_example.healthcheck;\r\n\r\nimport lombok.RequiredArgsConstructor;\r\nimport org.springframework.http.ResponseCookie;\r\nimport org.springframework.http.ResponseEntity;\r\nimport org.springframework.web.bind.annotation.GetMapping;\r\nimport org.springframework.web.bind.annotation.RestController;\r\nimport org.springframework.web.server.ServerWebExchange;\r\nimport reactor.core.publisher.Mono;\r\n\r\n@RequiredArgsConstructor\r\n@RestController\r\npublic class HealthcheckController {\r\n  private final HealthcheckService healthcheckService;\r\n  \r\n    // ... \r\n  static record ReadyStatusBody(\r\n      String message\r\n  ){}\r\n\r\n  @GetMapping(\"/healthcheck/ready/body\")\r\n  public Mono<ReadyStatusBody> readyWithBody(){\r\n    return Mono.just(healthcheckService.ok())\r\n        .map(message -> new ReadyStatusBody(message));\r\n  }\r\n}\n테스트\npackage io.chagchagchag.example.reactive_test_example.slice_test.verification;\r\n\r\n// ...\r\n\r\n@ExtendWith(SpringExtension.class)\r\n@ContextConfiguration(classes = HealthcheckController.class)\r\npublic class BodyVerificationTest {\r\n  @MockBean\r\n  private HealthcheckService healthcheckService;\r\n  @Autowired\r\n  private HealthcheckController healthcheckController;\r\n\r\n  static record ReadyStatusBody(\r\n      String message\r\n  ){}\r\n\r\n  @Test\r\n  public void TEST_BODY(){\r\n    String expected = \"OK\";\r\n    WebTestClient webTestClient = WebTestClient\r\n        .bindToController(healthcheckController)\r\n        .build();\r\n\r\n    Mockito.when(healthcheckService.ok())\r\n        .thenReturn(\"OK\");\r\n\r\n    ReadyStatusBody expectedBody = new ReadyStatusBody(expected);\r\n\r\n    webTestClient.get()\r\n        .uri(\"/healthcheck/ready/body\")\r\n        .exchange()\r\n        .expectHeader()\r\n        .contentType(MediaType.APPLICATION_JSON)\r\n        .expectBody(ReadyStatusBody.class)\r\n        .isEqualTo(expectedBody)\r\n        .value(r -> {\r\n          Assertions.assertThat(r.message).isEqualTo(expected);\r\n        });\r\n  }\r\n\r\n}"}},"/slice-test/what-is-mockbean":{"title":"What Is Mockbean","data":{"mockbean#@MockBean":"@MockBean 은 어떤 컴포넌트가 다른 컴포넌트에 의존성을 가지고 있으며, 그 컴포넌트를 가짜 객체로 지정해서 원하는 여러 가지 상황을 가정한 테스트를 Mocking 기반으로 수행하려 할 때 @MockBean 으로 선언합니다. @MockBean 은 Bean 으로 등록한 객체에 대해서만 지정 가능합니다.만약 일반 객체가 여러 객체를 의존하고 있고 의존관계의 객체를 Mocking 기반으로 테스트하고 싶다면, 의존객체에 대해서는 Mockito 의 @Mock 를 통해서 가짜 객체로 선언하고 의존객체를 묶어주는 것은 @InjectMocks 를 사용하면 됩니다.스프링에서 제공해주는 MockBean.java 의 코드는 아래와 같습니다.\npackage org.springframework.boot.test.mock.mockito;\r\n\r\nimport java.lang.annotation.Documented;\r\nimport java.lang.annotation.ElementType;\r\nimport java.lang.annotation.Repeatable;\r\nimport java.lang.annotation.Retention;\r\nimport java.lang.annotation.RetentionPolicy;\r\nimport java.lang.annotation.Target;\r\n\r\nimport org.junit.runner.RunWith;\r\nimport org.mockito.Answers;\r\nimport org.mockito.MockSettings;\r\n\r\nimport org.springframework.context.ApplicationContext;\r\nimport org.springframework.core.annotation.AliasFor;\r\nimport org.springframework.test.context.junit4.SpringRunner;\r\n\r\n\r\n@Target({ ElementType.TYPE, ElementType.FIELD })\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@Documented\r\n@Repeatable(MockBeans.class)\r\npublic @interface MockBean {\r\n\tString name() default \"\";\r\n    \r\n\t@AliasFor(\"classes\")\r\n\tClass<?>[] value() default {};\r\n\t\r\n    @AliasFor(\"value\")\r\n\tClass<?>[] classes() default {};\r\n\t\r\n    Class<?>[] extraInterfaces() default {};\r\n\t\r\n    Answers answer() default Answers.RETURNS_DEFAULTS;\r\n\t\r\n    boolean serializable() default false;\r\n\t\r\n    MockReset reset() default MockReset.AFTER;\r\n\r\n}","mockbean-을-이용한-테스트코드#@MockBean 을 이용한 테스트코드":"간단한 예제를 살펴보는 것으로 이번 문서를 마무리하겠습니다.","애플리케이션-코드#애플리케이션 코드":"@SpringBootApplication 적용 클래스\npackage io.chagchagchag.example.reactive_test_example;\r\n\r\nimport org.springframework.boot.SpringApplication;\r\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\r\n\r\n@SpringBootApplication\r\npublic class ReactiveTestExampleApplication {\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\tSpringApplication.run(ReactiveTestExampleApplication.class, args);\r\n\t}\r\n\r\n}\nHealthcheckController.java\npackage io.chagchagchag.example.reactive_test_example.healthcheck;\r\n\r\nimport lombok.RequiredArgsConstructor;\r\nimport org.springframework.web.bind.annotation.GetMapping;\r\nimport org.springframework.web.bind.annotation.RestController;\r\nimport reactor.core.publisher.Mono;\r\n\r\n@RequiredArgsConstructor\r\n@RestController\r\npublic class HealthcheckController {\r\n  private final HealthcheckService healthcheckService;\r\n  @GetMapping(\"/healthcheck/ready\")\r\n  public Mono<String> getReady(){\r\n    return Mono.just(healthcheckService.ok());\r\n  }\r\n}\nHealthcheckService.java\npackage io.chagchagchag.example.reactive_test_example.healthcheck;\r\n\r\nimport org.springframework.stereotype.Service;\r\n\r\n@Service\r\npublic class HealthcheckService {\r\n  public String ok(){\r\n    return \"OK\";\r\n  }\r\n}","테스트-코드#테스트 코드":"위와 같이 정의된 애플리케이션 코드를 테스트해봅니다.\npackage io.chagchagchag.example.reactive_test_example.slice_test.mock_bean;\r\n\r\nimport io.chagchagchag.example.reactive_test_example.healthcheck.HealthcheckController;\r\nimport io.chagchagchag.example.reactive_test_example.healthcheck.HealthcheckService;\r\nimport org.junit.jupiter.api.Test;\r\nimport org.junit.jupiter.api.extension.ExtendWith;\r\nimport org.mockito.Mockito;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.boot.test.mock.mockito.MockBean;\r\nimport org.springframework.test.context.ContextConfiguration;\r\nimport org.springframework.test.context.junit.jupiter.SpringExtension;\r\nimport reactor.core.publisher.Mono;\r\nimport reactor.test.StepVerifier;\r\n\r\n@ExtendWith(SpringExtension.class)\r\n@ContextConfiguration(\r\n    classes = {HealthcheckController.class}\r\n)\r\npublic class MockBeanTest {\r\n\r\n  @Autowired\r\n  private HealthcheckController healthcheckController;\r\n\r\n  @MockBean\r\n  private HealthcheckService healthcheckService;\r\n\r\n  @Test\r\n  public void MOCK_BEAN_TEST(){\r\n    // given\r\n    var expected = \"OK\";\r\n    Mockito.when(healthcheckService.ok())\r\n        .thenReturn(expected);\r\n\r\n    // when\r\n    Mono<String> getReady = healthcheckController.getReady();\r\n\r\n    // then\r\n    StepVerifier.create(getReady)\r\n        .expectNext(expected)\r\n        .verifyComplete();\r\n  }\r\n\r\n}\nHealthcheckService 컴포넌트를 Mocking 된 Bean 으로 주입받는 코드는 아래와 같습니다. 이렇게 하면 HealthcheckController 내에 healthcheckService 는 MockBean 기반의 객체로 주입받습니다.\n@MockBean\r\nprivate HealthcheckService healthcheckService;\r\n\r\n@Autowired\r\nprivate HealthcheckController healthcheckController;\n이번에는 Mockito 를 통해서 HealthcheckService 가 특정 동작을 하는지 가정을 해서 원하는 결과를 내는지 테스트하는 부분의 코드입니다.\n\r\n@Test\r\npublic void MOCK_BEAN_TEST(){\r\n    // given\r\n    var expected = \"OK\";\r\n    Mockito.when(healthcheckService.ok())\r\n        .thenReturn(expected);\r\n\r\n    // when\r\n    Mono<String> getReady = healthcheckController.getReady();\r\n\r\n    // then\r\n    StepVerifier.create(getReady)\r\n        .expectNext(expected)\r\n        .verifyComplete();\r\n}\ngiven\nhealthCheckService 객체의 ok() 메서드를 호출할 때 \"OK\" 라는 문자열을 리턴하는 상황을 가정합니다.\nwhen\nhealthCheckController 객체의 getReady() 가 호출되는 상황입니다.\nthen\n결과값을 검증합니다.\nStepVerifier 로 healthCheckController 가 이번 테스트 케이스의 조건에 대해 \"OK\" 라는 문자열을 리턴하는지 체크합니다."}},"/test-tips":{"title":"Test Tips","data":{"테스트-tips#테스트 Tips":"Private 메서드 테스트\nTest 객체 생성\nTest Double 이 뭐에요?"}},"/slice-test/what-is-slice-test":{"title":"What Is Slice Test","data":{"슬라이스-테스트란#슬라이스 테스트란?":"두꺼운 치즈를 자르면 하나의 슬라이스가 되듯 \"슬라이스 테스트\" 라는 용어의 의미는 여러 복합적인 기능 중 하나의 단면에 대한 레이어를 테스트한다는 의미를 가지고 있습니다.**\"슬라이스 테스트\"**는 스프링 프레임워크에서 제공하는 기능입니다. 예를 들면 Controller 의 경우에는 MockMVC 또는 @WebFluxTest 테스트를 통해 검증할수 있고, Data Access Layer 는 @DataR2dbcTest, 레디스는 @DataRedisTest, MongoDB 는 @DataMongoTest 애노테이션을 통해서 그 기능을 제공해줍니다.Web MVC\nMockMVC\n@WebFluxTest\nData Access Layer\n@DataR2dbcTest\n@DataRedisTest\n@DataMongoTest","controller-data-access-layer#Controller, Data Access Layer":"Service 나 내부 컴포넌트 들은 정해진 입력에 대해 정해진 동작을 하는 역할을 하게끔 작성이 가능합니다. 그런데 Service 계층이 아닌 Controller, Data Access Layer 는 외부의 입력을 받습니다.ControllerController 는 주어진 API 에 대한 비즈니스 요구사항에 맞는 요청과 응답을 검증해야 하는데 이 때 Service 및 내부 Component 들에 대해서는 Mocking 을 해서 테스트를 수행합니다. Controller 가 속한 프리젠테이션 레이어는 비즈니스 요구사항에 맞는 요청의 형식이나 응답코드, 응답 형식이 요구사항이 변할 때마다 대응이 가능해야 하는데 이에 맞는 테스트를 하는 영역입니다.그런데 이 Controller 는 단순히 요청 응답만 테스트 하는 것이 아니라 Netty 또는 Tomcat 컨테이너 위에서 잘 구동되는지 역시 검증이 가능해야 합니다. 따라서 단순한 기능의 검증을 넘어서 WAS 레벨에서의 테스트까지 수행해야 합니다. 이렇게 웹 컨테이너에서부터 API 의 비즈니스 요건 테스트에 대해서 Webflux 에서는 @WebFluxTest 라는 기능을 제공해줍니다.\nData Access LayerData Access Layer 는 R2DBC 와 같은 데이터베이스 클라이언트를 통해서 데이터베이스라고 하는 이종의 머신과 통신을 한 결과를 데이터로 응답합니다. Data Access Layer 계층에서는 DBMS 와 통신을 하는 것 외에도 실제 쿼리가 잘 짠 것인지도 테스트를 해봐야 합니다. 쿼리의 검증은 단순히 Java 코드로만은 검증이 불가능합니다. 실제로 존재하는 Database 를 소규모로 구성해서 테스트를 해봐야 합니다.이렇게 Data Access Layer 에서는 실제 쿼리를 검증하는 테스트 코드, Database 접근 로직 등을 테스트하기 위해서 @DataR2dbcTest, @DataRedisTest, @DataMongoTest 를 제공해주고 있습니다."}},"/test-tips/test-fixtures":{"title":"Test Fixtures","data":{"테스트-더미-객체-생성#테스트 더미 객체 생성":""}},"/test-tips/private-method-test":{"title":"Private Method Test","data":{"private-메서드-테스트#Private 메서드 테스트":""}},"/unit-test/assertj-assertions":{"title":"Assertj Assertions","data":{"assertions-assertj#Assertions (Assertj)":""}},"/unit-test":{"title":"Unit Test","data":{"유닛-테스트-unit-test#유닛 테스트 (Unit Test)":""}},"/test-tips/what-is-test-double":{"title":"What Is Test Double","data":{"test-double-이-뭔가요#Test Double 이 뭔가요?":""}},"/unit-test/assumption":{"title":"Assumption","data":{"assumption-junit-jupiter#Assumption (Junit Jupiter)":""}},"/unit-test/junit-jupiter":{"title":"Junit Jupiter","data":{"junit-jupiter#JUnit Jupiter":""}},"/unit-test/test-libraries":{"title":"Test Libraries","data":{"다양한-테스트-라이브러리#다양한 테스트 라이브러리":"JUnit5\nJUnit 5 User Guide\nAssertion, Assumption 라이브러리\nAssertJ\nJUnit5 Assertions\nJUnit5 Assumptions\nHamcrest\nTruth\nMockito Framework\nTestContainers"}},"/unit-test/what-is-unit-test":{"title":"What Is Unit Test","data":{"단위-테스트의-개념-원칙-목적#단위 테스트의 개념, 원칙, 목적":"","단위테스트란#단위테스트란?":"참고 : ko.wikipedia.org/wiki - 유닛테스트\n단위 테스트는 단위테스트 또는 유닛테스트라고 불립니다. ko.wikipedia.org/wiki - 유닛테스트 에서는 아래와 같이 단위테스트를 설명하고 있습니다.\n컴퓨터 프로그래밍에서 소스 코드의 특정 모듈이 의도된 대로 정확히 작동하는지 검증하는 절차\n즉, 모든 함수와 메소드에 대한 테스트 케이스(Test case)를 작성하는 절차\n이를 통해서 언제라도 코드 변경으로 인해 문제가 발생할 경우, 단시간 내에 이를 파악하고 바로 잡을 수 있는 것이 가능해짐\n이상적으로, 각 테스트 케이스는 서로 분리되어야 한다.\n이를 위해 가짜 객체(Mock object)를 생성하는 것도 좋은 방법\n예를 들어 아래와 같은 코드가 있다고 해보겠습니다.\n// ...\r\nprivate final CommentService commentService;\r\nprivate final CommentCntService commentCntService;\r\n// ...\r\n\r\nprivate final CleanPlatformFeignClient cleanPlatformClient;\r\n\r\n@Transactional\r\npublic void createComment(CommentCreateRequest request){\r\n    // ...\r\n    \r\n    // 1) \r\n    var response = cleanPlatformClient.fetchApi(url, payload);\r\n    \r\n    // 2)\r\n    if(response.isOk()){\r\n        // 3)\r\n        commentService.save(request);\r\n        \r\n        // 4)\r\n        commentCntService.save(request);\r\n    }\r\n    else{\r\n        throw new BadCommentCreateTryException(request);\r\n    }\r\n    \r\n}\n단위테스트는 위 코드에서 1), 2), 3), 4) 메서드 각각에 대한 테스트 케이스들을 만드는 것을 의미합니다. 그리고 1), 2), 3), 4) 내에도 세부적인 메서드 콜이 있다면 그 메서드가 수행하는 동작에 대한 단위 기능에 대한 테스트 케이스를 작성합니다.이때 하나의 단위 기능에서 여러가지 역할을 수행한다면 단위테스트가 모호해집니다. 단위 테스트 기반으로 코드를 작성하게 되면, 하나의 기능은 하나의 역할을 한다, 하나의 기능이 변경되는 이유는 하나의 이유로 변경되어야 한다는 SRP 원칙을 지킨 코드가 되도록 작성하기 수월해지게 됩니다.1) 의 코드는 Mocking 기반으로 실행해야 합니다. 외부 API의 경우에는 외부 API 내부의 요건에 따라 항상 같은 값을 돌려받을 수 있다는 보장이 없기에 테스트 코드에서는 Mocking 기반으로 작성해야 합니다.","first-원칙#FIRST 원칙":"클린 코드의 저자 Robert Martin 이 제시하는 규칙입니다. 효과적인 테스트를 위한 5가지 원칙을 제시하는데, 아래와 같습니다.\nF : Fast\nI : Isolated (or Independent)\nR : Repeatable\nS : Self-Validating\nT : Timely\nF : Fast단위 테스트는 빠르게 실행되어야 한다는 원칙입니다.단위 테스트는 여러가지 경우에 대해 다양한 경우를 테스트하기에 테스트의 속도가 빠를 수록 개발자들이 더 자주 테스트를 실행해서 코드를 수정하고 피드백을 받을 수 있도록 돕습니다.I : Isolated (or Independent)단위 테스트는 독립적으로 수행되어야 합니다. 하나의 테스트가 다른 테스트에 영향을 주지 않고 독립적으로 실행될 수 있어야 합니다.외부 API 호출, 메시지 큐 데이터 Consumer 동작은 단위테스트 코드 내에서는 Mocking 을 기반으로 작성해야 합니다.R : Repeatable단위테스트는 어떤 환경에서도 반복실행을 하더라도 같은 입력값에 대해 같은 결과값을 리턴해야 합니다. 이렇게 같은 입력에 대해 같은 결과값을 리턴하면 테스트가 신뢰할 수 있고 안정적으로 실행될 수 있음을 보장할 수 있게 됩니다.S : Self-validating단위 테스트는 수동으로 결과를 확인할 필요 없이 자동으로 실행될 수 있어야 하며, 테스트의 성공, 실패 여부를 테스트 코드 자체를 통해서 명확히 판단이 가능해야 합니다.또한 결과가 애매한 상황이 없어야 합니다.T : Timely테스트는 적절한 시점에 작성되어야 합니다. 코드의 변경사항이 발생하면, 테스트 코드도 함께 변경해서 일관된 상태를 유지하게끔 해야 합니다. 이렇게 항상 일관된 상태를 유지하게끔 하면 신뢰성, 유지보수성이 향상되게 됩니다."}},"/unit-test/jupiter-assertions":{"title":"Jupiter Assertions","data":{"assertions-junit-jupiter#Assertions (Junit Jupiter)":"","asserttrue-assertfalse#assertTrue, assertFalse":"// 1)\r\n@Test\r\npublic void ASSERT_TRUE_FALSE_SIMPLE(){\r\n    boolean someTrue = true;\r\n    Assertions.assertTrue(someTrue);\r\n\r\n    boolean someFalse = false;\r\n    Assertions.assertFalse(someFalse);\r\n}\r\n\r\n// 2)\r\n@Test\r\npublic void ASSERT_TRUE_FALSE_SUPPLIER(){\r\n    Assertions.assertTrue(()-> {\r\n        return true;\r\n    });\r\n}\n1)\n값 기반으로 Assert 를 합니다.\n2)\nSupplier 에 대한 Assert 를 수행합니다.\n예를 들면 Spring Cloud Function 등을 사용할 경우 단순 값이 아닌 Supplier 를 리턴하는 경우도 꽤 많은데, 이런 경우 Supplier 를 그대로 넘겨주어서 assert 를 수행하는 것이 가능합니다.","assertequals-assertnotequals#assertEquals, assertNotEquals":"값을 비교하는 Assertion 입니다.\n// 1)\r\n@Test\r\npublic void ASSERT_EQUALS_NOT_EQUALS_1(){\r\n    String s1 = \"HELLO\";\r\n    String s2 = \"HELLO\";\r\n    Assertions.assertEquals(s1, s2);\r\n}\r\n\r\npublic class Message{\r\n    private String payload;\r\n    public Message(String payload){\r\n      this.payload = payload;\r\n    }\r\n}\r\n\r\n// 2)\r\n@Test\r\npublic void ASSERT_EQUALS_NOT_EQUALS_2(){\r\n    Message m1 = new Message(\"111\");\r\n    Message m2 = new Message(\"222\");\r\n    Assertions.assertNotEquals(m1, m2);\r\n}\n1)\ns1, s2 를 비교합니다. String 내에는 equals() 메서드가 정의되어 있기 때문에 s1, s2 를 Assertions.assertEquals() 로 비교 시에 같은 값으로 판단됩니다.\n2)\nm1, m2 를 비교합니다. Message 내에는 equals() 메서드가 정의되어 있지 않기 때문에 m1, m2 를 Assert.assertNotEquals() 로 비교시 참으로 인식됩니다.","assertsame-assertnotsame#assertSame, assertNotSame":"assertSame(), assertNotSame() 의 비교는 값의 비교가 아닌 참조의 비교를 수행합니다.\npublic class Box{\r\n    int weight;\r\n    public Box(int weight){\r\n      this.weight = weight;\r\n    }\r\n    @Override\r\n    public boolean equals(Object o) {\r\n      if (this == o) {\r\n        return true;\r\n      }\r\n      if (o == null || getClass() != o.getClass()) {\r\n        return false;\r\n      }\r\n      Box box = (Box) o;\r\n      return weight == box.weight;\r\n    }\r\n}\r\n\r\n@Test\r\npublic void ASSERT_SAME_NOT_SAME(){\r\n    // 1) \r\n    Box b1 = new Box(10);\r\n    Box b2 = new Box(10);\r\n    Assertions.assertNotSame(b1, b2);\r\n    Assertions.assertEquals(b1, b2);\r\n\r\n    // 2)\r\n    String s1 = \"Hello\";\r\n    Supplier<String> lazyS2 = () -> s1;\r\n    Assertions.assertSame(s1, lazyS2.get());\r\n}\n1)\nb1, b2 비교시 Box 클래스 내에는 equals() 메서드가 정의되어 있기에 assertEquals(b1, b2) 의 결과는 true 이며, 참조값의 비교시 b1, b2 는 서로 다른 메모리 참조값을 가지기에 assertNotSame(b1, b2) 를 통해 b1, b2 의 메모리 주소가 다르다는 것을 확인가능합니다.\n똑같은 s1 변수를 리턴하는 assert 입니다. assertSame() 은 메모리 참조를 비교하기 때문에 assertSame(s1, lazyS2.get()) 의 결과는 true 입니다.","assertarrayequals-assertiterableequals#assertArrayEquals, assertIterableEquals":"배열 또는 Iterable 타입에 대해 값의 비교를 확인해봅니다.\n@Test\r\npublic void ASSERT_ARRAY_EQUALS_AND_ITERABLE_EQUALS(){\r\n    // 1)\r\n    String [] actualArray = {\"A\", \"B\", \"C\"};\r\n    String [] expectedArray = {\"A\", \"B\", \"C\"};\r\n    Assertions.assertArrayEquals(actualArray, expectedArray);\r\n\r\n    // 2)\r\n    List<String> actualList = List.of(\"A\",\"B\",\"C\");\r\n    List<String> expectedList = List.of(\"A\",\"B\",\"C\");\r\n    Assertions.assertIterableEquals(actualList, expectedList);\r\n}\n1)\nactualArray 와 expectedArray 는 각 요소의 순서, 값 모두 일치합니다.\n2)\nactualList 와 expectedList 모두 각 요소의 순서, 값 모두 일치합니다.","assertlinesmatch#assertLinesMatch":"assertLinesMatch 는 두개의 스트림의 모든 요소가 순서와 값이 모두 일치하거나, 두개의 리스트의 모든 요소가 순서와 값이 모두 일치하는 경우를 테스트할 때 사용합니다.\n@Test\r\npublic void ASSERT_LINES_MATCH(){\r\n    // 1)\r\n    Stream<String> sourceStream = Stream.of(\"A\", \"B\", \"C\");\r\n    Stream<String> targetStream = Stream.of(\"A\", \"B\", \"C\");\r\n    Assertions.assertLinesMatch(sourceStream, targetStream);\r\n\r\n    // 2)\r\n    List<String> sourceList = List.of(\"A\", \"B\", \"C\");\r\n    List<String> targetList = List.of(\"A\", \"B\", \"C\");\r\n    Assertions.assertLinesMatch(sourceList, targetList);\r\n}\n1)\nStream 내의 모든 요소의 순서와 값이 일치하기에 테스트가 실패하지 않습니다.\n2)\nList 내의 모든 요소의 순서와 값이 일치하기에 테스트가 실패하지 않습니다.","assertnull-assertnotnull#assertNull, assertNotNull":"Null 인지, Null 이 아닌지를 검사합니다. 간단한 예제이기에 설명은 생략합니다.\n@Test\r\npublic void ASSERT_NULL_NOT_NULL(){\r\n    String nullStr = null;\r\n    Assertions.assertNull(nullStr);\r\n\r\n    String apple = \"APPLE\";\r\n    Assertions.assertNotNull(apple);\r\n}","assertinstanceof#assertInstanceOf":"특정 타입에 해당하는지 검사합니다.\n@Test\r\npublic void ASSERT_INSTANCE_OF(){\r\n    var exception = new RuntimeException(\"어머, 예외가 발생했어요.\");\r\n    Assertions.assertInstanceOf(RuntimeException.class, exception);\r\n}","fail#fail":"특정 케이스에 테스트를 실패시켜야 할 경우 Assert.fail() 을 방출하도록 합니다. 유지보수로 인해 생긴 변경에 대한 테스트 케이스를 수정해야 함을 파악하기에 좋은 방식입니다.\n@Test\r\npublic void ASSERT_FAIL(){\r\n    Logger log = LoggerFactory.getLogger(JUnitAssertionsTest.class);\r\n    var exception = new RuntimeException(\"어머, 예외가 발생했어요.\");\r\n\r\n    if(exception != null)\r\n      Assertions.fail();\r\n    else{\r\n      log.info(\"예외가 발생하지 않았어요. 정상이에요.\");\r\n    }\r\n}\r\n\r\n@Test\r\npublic void ASSERT_TEST_MUST_FAIL(){\r\n    Logger log = LoggerFactory.getLogger(JUnitAssertionsTest.class);\r\n    var exception = new RuntimeException(\"어머, 예외가 발생했어요.\");\r\n\r\n    if(exception != null)\r\n      Assertions.fail(exception);\r\n    else{\r\n      log.info(\"예외가 발생하지 않았어요. 정상이에요.\");\r\n    }\r\n}","assertall#assertAll":"특정 단언문들을 한꺼번에 실행하고 싶을때가 있습니다. 또는 즉시 로딩하는 연산대신 lazy loading 을 하는 연산을 수행하고 싶을 경우가 있습니다. 이런 경우 junit.jupiter 의 Executable 을 활용해서 아래와 같이 Assertions.assertAll(Executable executables...) 을 수행하면 됩니다.\n@Test\r\npublic void ASSERT_ALL(){\r\n    Assertions.assertAll(\r\n        () -> {Assertions.assertTrue(true);},\r\n        () -> {Assertions.assertTrue(1 > 0);},\r\n        () -> {Assertions.assertTrue(List.of(1,2,3).size() == 3);}\r\n    );\r\n\r\n    Stream<Executable> stream = Stream.of(\r\n        () -> {Assertions.assertTrue(true);},\r\n        () -> {Assertions.assertTrue(1 > 0);},\r\n        () -> {Assertions.assertTrue(List.of(1,2,3).size() == 3);}\r\n    );\r\n    Assertions.assertAll(stream);\r\n}","assertthrows-assertthrowsexactly#assertThrows, assertThrowsExactly":"특정 비즈니스 로직의 유효성 체크나, 요건이 성립하지 않는 경우를 테스트하기 위해 Exception 을 내는 테스트 케이스를 해야 할 경우가 많습니다. 또한 비즈니스 로직에 따라서 Exception 의 종류도 다양하게 정의하고 여러 가지 경우의 수로 나누어서 여러가지 Exception 을 throw 합니다. 이런 경우에 대한 테스트는 assertThrows, assertThrowsExactly 를 사용합니다.\n@Test\r\npublic void ASSERT_THROWS_ASSERT_THROWS_EXACTLY(){\r\n    Assertions.assertThrows(\r\n        IllegalStateException.class,\r\n        () -> {\r\n          throw new IllegalStateException(\"예외가 발생했어요\");\r\n        }\r\n    );\r\n\r\n    Assertions.assertThrows(\r\n        RuntimeException.class, // IllegalArgumentException 은 RuntimeException 의 한 종류로 판단\r\n        () -> {\r\n          throw new IllegalStateException(\"예외가 발생했어요\");\r\n        }\r\n    );\r\n\r\n    /** 테스트가 실패합니다.\r\n     * RuntimeException 은 IllegalStateException 의 상위타입입니다.\r\n    Assertions.assertThrows(\r\n        IllegalStateException.class,\r\n        () -> {\r\n          throw new RuntimeException(\"asdf\");\r\n        }\r\n    );\r\n    */\r\n\r\n    Assertions.assertThrowsExactly(\r\n        IllegalStateException.class,\r\n        () -> {\r\n          throw new IllegalStateException(\"예외가 발생했어요\");\r\n        }\r\n    );\r\n\r\n    /** 테스트가 실패합니다.\r\n     * IllegalStateException RuntimeException 의 한 종류이지만,\r\n     * Assertions.assertThrowsExactly 는 정확하게 타입이 일치해야만 성공으로 인식합니다.\r\n    Assertions.assertThrowsExactly(\r\n        RuntimeException.class,\r\n        () -> {\r\n          throw new IllegalStateException(\"예외가 발생했어요\");\r\n        }\r\n    );\r\n    */\r\n}","assertdoesnotthrow#assertDoesNotThrow":"Exception 이 발생하지 않음을 보장합니다.\n@Test\r\npublic void ASSERT_DOES_NOT_THROW(){\r\n    Assertions.assertDoesNotThrow(\r\n        () -> {}\r\n    );\r\n\r\n    Assertions.assertDoesNotThrow(\r\n        () -> \"안녕하세요\"\r\n    );\r\n}","asserttimeout#assertTimeout":"@Test\r\npublic void ASSERT_TIMOUT(){\r\n    final Duration timeLimit = Duration.ofSeconds(1);\r\n\r\n    Assertions.assertTimeout(timeLimit, () -> {\r\n      sleep(500);\r\n    });\r\n\r\n    var externalResult = Assertions.assertTimeout(timeLimit, () -> {\r\n      sleep(500);\r\n      return true;\r\n    });\r\n    Assertions.assertTrue(externalResult);\r\n\r\n    /** 실패하는 케이스 : 미리 지정한 1초의 타임아웃을 넘어서는 케이스\r\n    Assertions.assertTimeout(timeLimit, () -> {\r\n      sleep(2000);\r\n    });\r\n    */\r\n}\r\n\r\npublic void sleep(long ms){\r\n    try{\r\n      Thread.sleep(ms);\r\n    }\r\n    catch (Exception e){\r\n      e.printStackTrace();\r\n    }\r\n}","asserttimeoutpreemptively#assertTimeoutPreemptively":"참고자료 : Junit5 Assertions/Assumptions 설명\n예를 들어 아래의 코드는 10초동안 기다려야 테스트가 끝납니다.\npublic void sleep(long ms){\r\n    try{\r\n      Thread.sleep(ms);\r\n    }\r\n    catch (Exception e){\r\n      e.printStackTrace();\r\n    }\r\n}\r\n\r\n@Test\r\npublic void ASSERT_TIMEOUT_NO_PREEMPTIVELY(){\r\n    final Duration timeLimit = Duration.ofSeconds(8);\r\n\r\n    var externalResult = Assertions.assertTimeout(timeLimit, () -> {\r\n      sleep(7000);\r\n      return true;\r\n    });\r\n    Assertions.assertTrue(externalResult);\r\n}\n위의 테스트 코드를 1초 동안만 기다렸다가, 1초 내에 테스트가 끝나지 않으면 종료시키려 할 경우 아래와 같이 작성합니다. 아래 코드는 익셉션을 내면서 종료됩니다.\n@Disabled\r\n@TestMustFail\r\npublic void ASSERT_TIMEOUT_PREEMPTIVELY(){\r\n    final Duration timeLimit = Duration.ofSeconds(1);\r\n\r\n    var externalResult = Assertions.assertTimeoutPreemptively(timeLimit, () -> {\r\n      sleep(7000);\r\n      return true;\r\n    });\r\n    Assertions.assertTrue(externalResult);\r\n}\r\n\r\n// @TestMustFail 은 아래와 같이 정의해두었습니다.\r\n@Target(ElementType.METHOD)\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@Test\r\npublic @interface TestMustFail {\r\n\r\n}\nassertTimeoutPreemptively 를 사용하면 오래 걸리는 작업이 정해둔 타임아웃 내에 끝나지 않으면 작업을 종료시킵니다. 이 과정에서 익셉션이 발생하기도 합니다. assertTimeoutPreemptively 는 독립적인 스레드로 실행하는데, 트랜잭션이 포함되어 있는 경우 트랜잭션 스레드와는 별개로 수행되어서 롤백이 안되는 경우가 생길 수 있습니다.오래 걸리는 작업인데, 결과값의 검증이 필요한 경우 assertTimeoutPreemptively 보다는 assertTimeout 을 사용하는 것이 낫습니다.\n무조건 사용을 안할 수는 없겠지만, 익셉션이 발생할 수도 있는 통신에 대한 환경 테스트가 필요한 경우 (e.g. 테스트 환경에서 특정 외부 API가 네트워크 접속이 되는지와 같은 테스트 전제 조건을 체크해야 할 경우) 에는 사용할수도 있는 아주 드문 케이스 중 하나입니다."}},"/what-is-software-test":{"title":"What Is Software Test","data":{"소프트웨어-테스트란#소프트웨어 테스트란?":"참고 : ko.wikipedia.org/wiki - 소프트웨어 테스트\n소프트웨어 테스트는 주요 이해관계자들에게 시험 대상 제품, 서비스 품질에 대한 정보를 제공하는 조사과정입니다.소프트웨어 테스트는 아래의 특징들을 제공합니다.\n소프트웨어에 대한 객관적이고 독립적인 시각을 제공\n사업 주체가 소프트웨어 구현의 위험성을 올바로 이해할 수 있도록 도움을 제공","소프트웨어-테스트의-7가지-원칙#소프트웨어 테스트의 7가지 원칙":"참고: ISTQB Foundation Level - Seven testing Principles\nISTQB 에서 정의하는 소프트웨어의 7가지 원칙은 아래와 같습니다.\nTesting shows the presence of defects, not their absence\n테스트는 결함의 부재가 아닌, 결함의 존재를 보여줘야 합니다.\n테스트를 통해 소프트웨어의 결함을 확인할 수 있습니다.\nExhaustive testing is impossible\n완벽한 테스트는 불가능합니다.\nEarly testing saves time and money\n일찍 진행한 테스트는 비용을 줄여줍니다.\nDefects cluster together\n결함은 집중되고 군집(클러스터)되는 경향이 있습니다.\nBeware of the pesticide paradox\n살충제 패러독스에 빠지지 않도록 해야합니다.\nTesting is context-dependent\n테스트는 주변 환경에 의존적입니다.\nAbsence-of-errors is a fallacy\n오류가 없다는 것은 오류입니다.","testing-shows-the-presence-of-defects-not-their-absence#Testing shows the presence of defects, not their absence":"테스트는 결함의 부재가 아닌, 결함의 존재를 보여줘야 합니다.\n테스트를 통해 소프트웨어의 결함을 확인할 수 있다.\n테스트는 소프트웨어의 결함을 찾기 위한 과정이며, 소프트웨어에 결함이 있다는 것을 보여주는 과정입니다. 테스트는 결함을 찾아가는 과정이며, 완전하게 오류가 없음을 보장하지는 않습니다. 다만 일정 수준의 테스트를 통해서 소프트웨어의 정상 작동 범위를 보장할 수 있고 신뢰성을 높일 수 있습니다.","exhaustive-testing-is-impossible#Exhaustive testing is impossible":"완벽한 테스트는 불가능합니다.\n모든 입력, 전제조건들을 일일이 테스트하는 것은 실제로는 불가능합니다. 테스트에 필요한 인적, 시간적 리소스는 한정적입니다. 따라서 필요한 기능과 정합성이 보장되어야 하는 요소를 적절하게 선정해서 테스트를 적용해야 합니다.","early-testing-saves-time-and-money#Early testing saves time and money":"일찍 진행한 테스트는 비용을 줄여줍니다.\n테스트는 일찍 진행할 수록 비용이 줄어듭니다. 요구사항 수립, 개발작업 사이에 먼저 테스트를 통해 발견한 버그는 QA 시에 발생하는 시간적, 인적 리소스를 줄여줍니다.","defects-cluster-together#Defects cluster together":"결함은 집중되고 군집(클러스터)되는 경향이 있습니다.\n결함은 특정 요소에 클러스터처럼 퍼져있는 경우가 많습니다.","beware-of-the-pesticide-paradox#Beware of the pesticide paradox":"살충제 패러독스에 빠지지 않도록 해야합니다.\n시간이 지남에 따라 동일한 테스트 케이스를 반복해서 수행하는 것은 지양해야 합니다. 동일한 테스트를 반복하면, 소프트웨어가 정상적으로 수행되는 것은 확인이 가능하지만, 새로운 문제는 발견해내지 못합니다.테스트를 정기적으로 업데이트하고 검토하면서 테스트를 개선시켜나가야 합니다.","testing-is-context-dependent#Testing is context-dependent":"테스트는 주변 환경에 의존적입니다.\n테스트는 주변 환경에 따라서 완전히 달라질 수 있습니다. 프로젝트 마다 요구되는 주변 상황, 환경 등을 고려해서 테스트의 환경을 커스터마이징해야 합니다. 예를 들면 증권 시세 데이터서비스와 원장 서비스는 환경이 다릅니다. 각각의 환경에 맞는 테스트 환경을 수립해야 합니다.","absence-of-errors-is-a-fallacy#Absence-of-errors is a fallacy":"오류가 없다는 것은 오류입니다.\n소프트웨어에 결함이 없다는 것이 단순히 소프트웨어에 결함이 없다는 것을 보장하지는 않습니다. 테스트의 목표를 100% 결함을 찾아내는 것에 목적을 두기보다 사용자에게 제공되는 기능이 올바른지를 검증하는 데에 목적을 두어야 합니다.","테스트의-목적#테스트의 목적":"테스트의 장점은 버그를 검증하거나, 특정 조건 내에서 이 기능이 꼭 성공함을 보장한다거나 특정 기능의 명세는 이런 요구사항을 가짐을 명세화할 경우 테스트는 장점을 가집니다. 완벽한 결함 제거 보다는 꼭 성공해야 하는 필수적인 기능에 대해 기능의 검증을 반복해서 자동화 기반으로 검증할 수 있다면 좋습니다.","테스트의-종류#테스트의 종류":"테스트의 종류는 단위테스트, 슬라이스테스트, 통합테스트가 있습니다. 이번 github 페이지에서는 이 내용들을 다룹니다."}},"/slice-test/r2dbc-h2-settings":{"title":"R2dbc H2 Settings","data":{"r2dbc-h2-설정#r2dbc h2 설정":"Spring Boot Starter Web 에서는 h2-console을 설정하는 것 만으로 h2-console을 사용할 수 있지만, Spring Boot Starter Web 에서는 별도로 h2 서버를 코드로 구현해서 사용해야 합니다.라이브러리 역시 다른 라이브러리를 사용하게 됩니다.\nSpring MVC : com.h2database:h2\nSpring Reactive Data : io.r2dbc:r2dbc-h2","참고자료#참고자료":"Spring 비동기 처리의 이해 3(Webflux with R2DBC, 게시판 만들기)\nSpring WebFlux + R2DBC 환경에서 H2 web console 사용하기","buildgradlekts#build.gradle.kts":"dependencies {\r\n    // ...\r\n    \r\n\timplementation(\"org.springframework.boot:spring-boot-starter-data-r2dbc\")\r\n    \r\n    // ...\r\n    \r\n\t// h2\r\n//\truntimeOnly(\"com.h2database:h2\")\r\n\timplementation(\"io.r2dbc:r2dbc-h2\")\r\n\r\n    // ...\r\n}","application-h2yml#application-h2.yml":"테스트 코드는 h2 로 설정하고 실행시에는 spring.profiles.active = h2  로 실행되도록 실행 인자를 넘겨주는 방식으로 실행하도록 지정했습니다.\nspring:\r\n  config:\r\n    import:\r\n      - classpath:h2.yml","h2yml#h2.yml":"spring:\r\n  sql:\r\n    init:\r\n      schema-locations: classpath*:sql/schema.sql\r\n      data-locations: classpath*:sql/data.sql\r\n  r2dbc:\r\n    url: r2dbc:h2:mem:///tset;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE\r\n    username: sa\r\n    password:\r\nh2:\r\n  console:\r\n    port: 8090","sql#sql":"src/test/resources/sql\ndata.sql\nschema.sql\nsrc/test/resources/sql/schema.sql\nCREATE TABLE MEMBER(\r\n    id BIGINT AUTO_INCREMENT PRIMARY KEY,\r\n    name VARCHAR(255) NOT NULL,\r\n    email VARCHAR(255) NOT NULL,\r\n    roles VARCHAR(255),\r\n    password VARCHAR(255) NOT NULL,\r\n    created_at DATETIME NOT NULL,\r\n    updated_at DATETIME NOT NULL\r\n);\r\n\r\nCREATE TABLE AUTH (\r\n    id BIGINT AUTO_INCREMENT PRIMARY KEY,\r\n    user_id BIGINT NOT NULL,\r\n    token VARCHAR(255) NOT NULL,\r\n    created_at DATETIME NOT NULL,\r\n    updated_at DATETIME NOT NULL\r\n);\nsrc/test/resources/sql/data.sql\n-- 아직 아무 내용도 작성을 하지 않음","h2serverconfig#H2ServerConfig":"h2 서버를 구동시키는 코드입니다.\npackage io.chagchagchag.oauth2client.oauth2_client_example.config;\r\n\r\nimport java.sql.SQLException;\r\nimport org.h2.tools.Server;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\nimport org.springframework.beans.factory.annotation.Value;\r\nimport org.springframework.context.annotation.Profile;\r\nimport org.springframework.context.event.ContextClosedEvent;\r\nimport org.springframework.context.event.ContextRefreshedEvent;\r\nimport org.springframework.context.event.EventListener;\r\nimport org.springframework.stereotype.Component;\r\n\r\n@Profile(\"h2\")\r\n@Component\r\npublic class H2ServerConfig {\r\n  private static final Logger logger = LoggerFactory.getLogger(H2ServerConfig.class);\r\n\r\n  @Value(\"${h2.console.port}\")\r\n  private Integer port;\r\n  private Server h2Server;\r\n\r\n  @EventListener(ContextRefreshedEvent.class)\r\n  public void start() throws SQLException {\r\n    logger.info(\"start h2 console at port {}\", port);\r\n    this.h2Server = Server.createWebServer(\"-webPort\", port.toString());\r\n    this.h2Server.start();\r\n  }\r\n\r\n  @EventListener(ContextClosedEvent.class)\r\n  public void stop(){\r\n    logger.info(\"stop h2 console at port {}\", port);\r\n    this.h2Server.stop();\r\n  }\r\n}","h2r2dbcconfig---r2dbc-커넥션-설정-connectionfactory-etc#H2R2dbcConfig - r2dbc 커넥션 설정 (ConnectionFactory, etc)":"package io.chagchagchag.oauth2client.oauth2_client_example.config;\r\n\r\nimport io.r2dbc.h2.H2ConnectionConfiguration;\r\nimport io.r2dbc.h2.H2ConnectionFactory;\r\nimport io.r2dbc.h2.H2ConnectionOption;\r\nimport io.r2dbc.spi.ConnectionFactory;\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.context.annotation.Configuration;\r\nimport org.springframework.context.annotation.Profile;\r\nimport org.springframework.data.r2dbc.config.AbstractR2dbcConfiguration;\r\nimport org.springframework.data.r2dbc.repository.config.EnableR2dbcRepositories;\r\nimport org.springframework.r2dbc.connection.init.ConnectionFactoryInitializer;\r\n\r\n@Profile(\"h2\")\r\n@EnableR2dbcRepositories\r\n@Configuration\r\npublic class H2R2dbcConfig extends AbstractR2dbcConfiguration {\r\n\r\n  @Override\r\n  public ConnectionFactory connectionFactory() {\r\n    return new H2ConnectionFactory(\r\n        H2ConnectionConfiguration.builder()\r\n            .inMemory(\"test\")\r\n            .property(H2ConnectionOption.DB_CLOSE_DELAY, \"-1\")\r\n            .username(\"sa\")\r\n            .build()\r\n    );\r\n  }\r\n\r\n  @Bean\r\n  public ConnectionFactoryInitializer h2DbInitializer(){\r\n    ConnectionFactoryInitializer initializer = new ConnectionFactoryInitializer();\r\n//    ResourceDatabasePopulator resourceDatabasePopulator = new ResourceDatabasePopulator();\r\n//    resourceDatabasePopulator.addScript(new ClassPathResource(\"/sql/schema.sql\"));\r\n//    resourceDatabasePopulator.addScript(new ClassPathResource(\"/sql/data.sql\"));\r\n//    initializer.setDatabasePopulator(resourceDatabasePopulator);\r\n    initializer.setConnectionFactory(connectionFactory());\r\n    return initializer;\r\n  }\r\n\r\n}","테스트-구동#테스트 구동":"아래의 contextLoads 메서드를 spring.profiles.active = h2 로 실행시켜시면 됩니다.\npackage io.chagchagchag.oauth2client.oauth2_client_example;\r\n\r\nimport org.junit.jupiter.api.Test;\r\nimport org.springframework.boot.test.context.SpringBootTest;\r\nimport org.springframework.test.context.ActiveProfiles;\r\n\r\n@ActiveProfiles({\"h2\"})\r\n@SpringBootTest\r\nclass Oauth2ClientExampleApplicationTests {\r\n\r\n\t@Test\r\n\tvoid contextLoads() {\r\n\t}\r\n\r\n}","간단한-테스트#간단한 테스트":"","memberentity#MemberEntity":"package io.chagchagchag.oauth2client.oauth2_client_example.member.entity;\r\n\r\nimport java.time.LocalDateTime;\r\nimport lombok.AllArgsConstructor;\r\nimport lombok.Builder;\r\nimport lombok.Getter;\r\nimport org.springframework.data.annotation.CreatedDate;\r\nimport org.springframework.data.annotation.Id;\r\nimport org.springframework.data.annotation.LastModifiedDate;\r\nimport org.springframework.data.annotation.PersistenceCreator;\r\nimport org.springframework.data.relational.core.mapping.Table;\r\n\r\n@Getter\r\n@Table(\"MEMBER\")\r\n@AllArgsConstructor(staticName = \"ofAll\")\r\npublic class MemberEntity {\r\n  @Id\r\n  private Long id;\r\n\r\n  private String name;\r\n  private String email;\r\n  private String roles;\r\n\r\n  @CreatedDate\r\n  private LocalDateTime createdAt;\r\n\r\n  @LastModifiedDate\r\n  private LocalDateTime updatedAt;\r\n\r\n  @PersistenceCreator\r\n  public MemberEntity(\r\n      Long id, String name, String email, String roles\r\n  ){\r\n    this.id = id;\r\n    this.name = name;\r\n    this.email = email;\r\n    this.roles = roles;\r\n  }\r\n\r\n  @Builder(builderClassName = \"CreateUserBuilder\", builderMethodName = \"createBuilder\")\r\n  public MemberEntity(\r\n      String name, String email, String roles\r\n  ){\r\n    this(null, name, email, roles);\r\n  }\r\n\r\n}","memberentityfactory#MemberEntityFactory":"package io.chagchagchag.oauth2client.oauth2_client_example.member.entity.factory;\r\n\r\nimport io.chagchagchag.oauth2client.oauth2_client_example.member.entity.MemberEntity;\r\nimport io.chagchagchag.oauth2client.oauth2_client_example.member.security.MemberRoles;\r\nimport org.springframework.stereotype.Component;\r\n\r\n@Component\r\npublic class MemberEntityFactory {\r\n  public MemberEntity ofCreateRoleMember(\r\n      String name, String email\r\n  ){\r\n    MemberRoles userRole = MemberRoles.ROLE_USER;\r\n    return MemberEntity.createBuilder()\r\n        .name(name)\r\n        .email(email)\r\n        .roles(userRole.getRoleName())\r\n        .build();\r\n  }\r\n}","memberr2dbccommandrepository#MemberR2dbcCommandRepository":"package io.chagchagchag.oauth2client.oauth2_client_example.member.entity.repository;\r\n\r\nimport io.chagchagchag.oauth2client.oauth2_client_example.member.entity.MemberEntity;\r\nimport org.springframework.data.repository.reactive.ReactiveCrudRepository;\r\n\r\npublic interface MemberR2dbcCommandRepository extends ReactiveCrudRepository<MemberEntity, Long> {\r\n\r\n}","memberr2dbcsearchrepository#MemberR2dbcSearchRepository":"package io.chagchagchag.oauth2client.oauth2_client_example.member.entity.repository;\r\n\r\nimport io.chagchagchag.oauth2client.oauth2_client_example.member.entity.MemberEntity;\r\nimport org.springframework.data.repository.reactive.ReactiveSortingRepository;\r\nimport reactor.core.publisher.Mono;\r\n\r\npublic interface MemberR2dbcSearchRepository extends ReactiveSortingRepository<MemberEntity, Long> {\r\n  Mono<MemberEntity> findMemberEntityByEmail(String email);\r\n}","datar2dbctest-테스트-코드#@DataR2dbcTest 테스트 코드":"package io.chagchagchag.oauth2client.oauth2_client_example.member;\r\n\r\nimport io.chagchagchag.oauth2client.oauth2_client_example.config.H2R2dbcConfig;\r\nimport io.chagchagchag.oauth2client.oauth2_client_example.member.entity.MemberEntity;\r\nimport io.chagchagchag.oauth2client.oauth2_client_example.member.entity.factory.MemberEntityFactory;\r\nimport io.chagchagchag.oauth2client.oauth2_client_example.member.entity.repository.MemberR2dbcCommandRepository;\r\nimport io.chagchagchag.oauth2client.oauth2_client_example.member.entity.repository.MemberR2dbcSearchRepository;\r\nimport org.junit.jupiter.api.Test;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.boot.test.autoconfigure.data.r2dbc.DataR2dbcTest;\r\nimport org.springframework.context.annotation.Import;\r\nimport org.springframework.test.context.ActiveProfiles;\r\nimport reactor.core.publisher.Mono;\r\nimport reactor.test.StepVerifier;\r\n\r\n@ActiveProfiles({\"h2\"})\r\n@Import(H2R2dbcConfig.class)\r\n@DataR2dbcTest\r\npublic class MemberEntityRepositoryH2Test {\r\n  @Autowired\r\n  private MemberR2dbcSearchRepository memberR2DbcSearchRepository;\r\n  @Autowired\r\n  private MemberR2dbcCommandRepository memberR2dbcCommandRepository;\r\n  private MemberEntityFactory memberEntityFactory;\r\n\r\n  @Test\r\n  public void TEST_MEMBER_INSERT(){\r\n    memberEntityFactory = new MemberEntityFactory();\r\n\r\n    // given\r\n    MemberEntity member = memberEntityFactory.ofCreateRoleMember(\"제시린가드\", \"abc@gmail.com\");\r\n\r\n    // when\r\n    Mono<MemberEntity> saved = memberR2dbcCommandRepository.save(member)\r\n        .flatMap(memberEntity -> memberR2DbcSearchRepository.findMemberEntityByEmail(member.getEmail()));\r\n\r\n    // then\r\n    StepVerifier.create(saved)\r\n        .expectNextMatches(memberEntity -> memberEntity.getEmail().equals(member.getEmail()));\r\n  }\r\n}"}}}