{"/":{"title":"Introduction","data":{"":"JUnit Jupiter 기반 단위테스트\nMockito 기반 다양한 단위테스트\nSpring Reactive 에서의 테스트\n슬라이스 테스트 (Web, Data)\n통합 테스트"}},"/integration-test":{"title":"Integration Test","data":{"통합-테스트-integration-test#통합 테스트 (Integration Test)":""}},"/reactor-test/if-without-stepverifier":{"title":"If without Stepverifier","data":{"stepverifier-없이-테스트할-경우#StepVerifier 없이 테스트할 경우":"StepVerifier 없이 테스트할 경우의 단점들에 대해 알아봅니다.","1-데이터를-즉시-로딩하는-테스트#1) 데이터를 즉시 로딩하는 테스트":"@Test\r\npublic void TEST_FLUX_1_BY_TO_LIST_BLOCK(){\r\n    Flux<Integer> numbers = Flux.create(sink -> {\r\n      for(int i=0; i<10; i++) sink.next(i);\r\n      sink.complete();\r\n    });\r\n\r\n    var expectedList = IntStream.range(0, 10)\r\n        .boxed()\r\n        .collect(Collectors.toList());\r\n\r\n    var actualList = numbers.collectList().block();\r\n\r\n    Assertions.assertIterableEquals(expectedList, actualList);\r\n}\nStream 과 Iterable 의 차이점, 단점 등에서 자주 언급되듯, Iterable 은 모든 데이터를 한번에 전달해줍니다. 반면 Stream 은 데이터를 게으르게 전달해주며, 한번에 데이터를 모아서 전달해주는 방식이 아닙니다. Flux 역시도 데이터를 한번에 모아서 Publish 하는 Publisher 가 아닙니다.따라서 위의 코드 처럼 Flux 를 Iterable 로 변환해서 테스트하는 것은 비효율적입니다. 틀린 코드는 아니지만 Flux 의 장점을 활용하지 못한 코드입니다.","2-예외-발생-직전의-요건을-테스트하기-쉽지-않다#2) 예외 발생 직전의 요건을 테스트하기 쉽지 않다":"@Test\r\npublic void TEST_FLUX_2_THROW_EXCEPTION_STATEMENT(){\r\n    Flux<Integer> numbers = Flux.create(sink -> {\r\n      for(int i=0; i<10; i++) {\r\n        sink.next(i);\r\n        if(i==5) sink.error(new RuntimeException(\"잠깐 멈춰봐요\"));\r\n      }\r\n      sink.complete();\r\n    });\r\n\r\n    Assertions.assertThrows(RuntimeException.class, () -> {\r\n      numbers.collectList().block();\r\n    });\r\n}\ni=5 일 때 RuntimeException 을 내고 있습니다. 만약 RuntimeException 이 발생하기 전에 i=4 일때 어떤 값이 있었는지, 어떤 데이터였는지 요건을 파악하고 싶다면 어떻게 해야 할까요?  테스트를 위해서 Flux 의 바깥에 조건변수를 두거나 여러가지 제어 구문을 적용해야만 할 것입니다.위의 코드는 정상적인 코드이지만, Webflux 의 StepVerifier 를 활용한다면 조금 더 유연한 테스트가 가능해집니다.","3-delay-및-timeout-이-적용된-코드-테스트시-어려움#3) Delay 및 Timeout 이 적용된 코드 테스트시 어려움":"@Test\r\npublic void TEST_FLUX_3_HEAVY_JOB_TEST(){\r\n    Flux<Integer> numbers = Flux.range(0, 10)\r\n        .delayElements(Duration.ofSeconds(2));\r\n\r\n    var expectedList = IntStream.range(0, 10)\r\n        .boxed()\r\n        .collect(Collectors.toList());\r\n\r\n    var actualList = numbers.collectList().block();\r\n\r\n    Assertions.assertIterableEquals(expectedList, actualList);\r\n}\n한 개의 요소를 순회할 때마다 2초가 걸리며 10개의 요소를 순회합니다. 이렇게 되면 테스트 시에 20초의 시간이 소요됩니다. 이렇게 되면 테스트의 FIRST 원칙 중 F (Fast) 원칙을 위배하게 됩니다.어떤 로직이 10분마다 한번씩 실행되는지를 테스트해보고 싶은 경우에는 어떻게 해야할까요? 또는 어떤 메일 발송 로직이 1일마다 한번씩 실행됨을 보장하려면 어떻게 해야 할까요? StepVerifier 의 withVirtualTime 을 사용하면 이런 테스트에 대해서 유연하게 대응이 가능해집니다."}},"/reactor-test/stepverifier-test":{"title":"Stepverifier Test","data":{"stepverifier-테스트#StepVerifier 테스트":"StepVerifier 를 기반으로 테스트를 수행하면 Publisher 를 다양한 방식들로 활용해서 여러가지 이벤트를 활용해서 검증이 가능해집니다.","실행-방식#실행 방식":"StepVerifier.create(), StepVerifier.withVirtualTime()Publisher 를 생성하는 것은 StepVerifier.create() 또는 StepVerifier.withVirtualTime() 을 통해 생성합니다.FirstStep, Step, LastStepStepVerifier 는 FirstStep, Step, LastStep 으로 구성됩니다.FirstStep\nFirstStep 은 처음 받는 이벤트인 onSubscription 과 관련된 객체입니다.\nStep\nStep 은 이후에 들어오는 이벤트 들을 순차적으로 검증할 때 사용하는 객체입니다.\nLastStep\nLastStep 은 최종 결과를 검증할 때 사용합니다.\n위의 검증이 모두 실패하면 테스트는 실패합니다.StepVerifier 내부의 코드를 보면, create() 메서드는 FirstStep 을 반환한다는 사실을 알 수 있습니다.\nFirstStep 타입(interface) 내에서는 expectSubscription() 메서드의 리턴 값은 Step<T> 을 리턴한다는 사실을 알 수 있습니다. expectSubscription() 을 통해 subscription 을 시작하게 되면 onNext 이벤트가 내부적으로 발생하게 됩니다. 또는 expectSubscription() 을 명시적으로 호출하지 않아도 FirstStep 타입은 Step 타입을 상속하고 있기 때문에 Step 타입내의 expectSubscription() 없이 바로 expectNext() 메서드를 통해 onNext 이벤트를 발생시키는 것이 가능합니다.\nStep 타입(interface) 내에서는 exepectNext() 메서드를 통해 onNext 이벤트를 처리하며, 그 다음 onNext 이벤트 들을 체이닝 방식으로 처리가 가능하도록 Step<T> 을 리턴하고 있다는 사실을 확인 가능합니다.\n다음은 LastStep 입니다. LastStep 에서는 complete(), verifyComplete() 메서드를 제공하고 있습니다.","firststep#FirstStep":"","내부-정의#내부 정의":"StepVerifier 내부의 코드를 보면, StepVerifier 의 create() 메서드는 FirstStep 을 반환한다는 사실을 알 수 있습니다. FirstStep 타입의 객체는 이렇게 StepVerifier 의 create() 메서드를 통해서 생성가능합니다.위의 캡처에서 가장 마지막의 create() 메서드를ㄹ 보면 FirstStep 을 생성 시에는 Subscription 에 전달할 requet 수, StepVerifierOptions 를 인자로 받고 있습니다.StepVerfierOptions 클래스를 이용하면, initialRequest 필드를 이용해서 Subscription 에 전달할 request 수를 지정할 수 있고, withInitialContext 필드를 이용해서 Context 등과 같은 별도의 정보들을 지정하는 것 역시 가능합니다.FirstStep 타입 내에는 expectSubscription() 이라는 메서드가 존재합니다.이 expectSubscription() 메서드는 onSubscribe 이벤트에 대한 테스트 메서드 입니다. expectSubscription 메서드를 호출한 이후부터는 Step 을 이용해서 계속해서 체이닝이 가능해지게 됩니다. FirstStep 은 Step 을 상속하고 있기 때문에 expectSubscriptio() 메서드를호출하지 않고도 바로 다음단계인 Step 으로 넘어가는 것 역시 가능합니다.","eg-expectnext#e.g. expectNext":"Step 에서 테스트해볼 내용이지만, 이번 섹션에서는 단순한 예제를 하나 정리해봅니다.\n@Test\r\npublic void TEST_FIRST_STEP_SIMPLE_1(){\r\n    Flux<Integer> numbers = Flux.range(0, 11);\r\n\r\n    StepVerifier.create(numbers)\r\n        .expectSubscription()\r\n        .expectNext(0,1,2,3,4)  // 1)\r\n        .expectNextCount(3) \t// 2) 실제 값 : 5,6,7\r\n        .expectNext(8,9,10)     // 3) \r\n        .verifyComplete();\r\n}\n1)\nexpectNext 를 통해서 0, 1, 2, 3, 4 의 값을 받습니다. onNext 이벤트가 5번 발생했다는 의미와 같습니다.\n2)\nexpectNextCount 를 통해서 3 개의 요소를 받습니다. expectNextCount(count) 메서드 내에 count 로 명시한 값은 뒤에서 몇개의 값을 onNext로 더 받을지를 의미합니다.\n3)\nexpectNext 를 통해서 8, 9, 10 의 값을 받습니다.","eg-initialrequest#e.g. initialRequest":"테스트하려는 Flux 의 크기를 알 수 없는 경우가 있습니다. 이런 경우 테스트 하려는 Flux 중에서 몇번째 까지만을 테스트할지를 명시할 수 있습니다. 아래 코드 처럼 StepVerifier.create(flux, initialRequestSize) 형태의 StepVerifier.create 메서드를 사용하면 \"Flux 의 맨 처음 요소부터 initialRequestSize 까지를 onSubscribe 이벤트 발생시 읽어들인다\" 라는 의미가 됩니다. 그리고 그 뒤의 요소는 꼭 thenCancel().verify() 등과 같은 종료연산을 통해 종료를 시켜줘야 합니다.\n@Test\r\npublic void TEST_FIRST_STEP_SIMPLE_2(){\r\n    Flux<Integer> numbers = Flux.range(0, 11);\r\n    var initialRequestSize = 3;\r\n\r\n    StepVerifier.create(numbers, initialRequestSize)\r\n        .expectSubscription()\r\n        .expectNext(0, 1, 2).as(\"first\")\r\n        .thenCancel()\r\n        .verify();\r\n\r\n    StepVerifier.create(numbers, initialRequestSize)\r\n        .expectNext(0).as(\"1 of 3\")\r\n        .expectNext(1).as(\"2 of 3\")\r\n        .expectNext(2).as(\"3 of 3\")\r\n        .thenCancel()\r\n        .verify();\r\n}\n그런데 만약 thenCancel().verify() 대신 verifyComplete() 같은 메서드를 사용할 경우 테스트는 멈추지 않고 계속 무한히 수행됩니다. 데이터의 끝을 모르는 채로 StepVerifier 가 Flux 퍼블리셔를 구독하고 있게 되기 때문입니다.","stepverifieroptions#StepVerifierOptions":"FirstStep 을 이용해서 Step 을 생성할 때에는 StepVerifierOptions 를 이용해서 initialRequest 와 같은 옵션을 지정해줄 수 있습니다.\n@Test\r\npublic void TEST_FIRST_STEP_VERIFIER_OPTIONS(){\r\n    // 1)\r\n    StepVerifierOptions option = StepVerifierOptions.create()\r\n        .initialRequest(3)\r\n        .checkUnderRequesting(false)\r\n        .scenarioName(\"simple 2\");\r\n\r\n    Flux<String> message = Flux.just(\"A\",\"B\",\"C\",\"D\",\"E\");\r\n\r\n    // 2)\r\n    StepVerifier\r\n        .create(message, option)\r\n        .expectSubscription()\r\n        .expectNext(\"A\",\"B\",\"C\").as(\"first\")\r\n        .thenRequest(2)\r\n        .expectNextCount(2).as(\"second\")\r\n        .expectComplete()\r\n        .verify();\r\n\r\n    // 3)\r\n    StepVerifier\r\n        .create(message, option)\r\n        .expectSubscription()\r\n        .expectNext(\"A\",\"B\",\"C\").as(\"first\")\r\n        .thenCancel()\r\n        .verify();\r\n}\nStepVerifierOptions 의 initialRequest 를 지정해주면, 데이터의 크기를 알수없는 Flux 에 대해 전체 Flux 를 소모하는 것이 아니라 필요한 부분만을 소모해서 테스트 후 테스트를 종료할 수 있습니다. 실제 서비스 운영시에는 읽어와야 할 데이터의 사이즈를 알수 없는 경우가 많습니다. 이런 경우 필요한 부분까지만 읽어들이고 중지해서 과도한 리소스 소모를 방지합니다.그런데 만약 thenCancel().verify() 대신 verifyComplete() 같은 메서드를 사용할 경우 테스트는 멈추지 않고 계속 무한히 수행됩니다. 데이터의 끝을 모르는 채로 StepVerifier 가 Flux 퍼블리셔를 구독하고 있게 되기 때문입니다.1)\ninitialRequest 에 대해 3개의 요소를 request 하고 있습니다. 이렇게 지정하면 3개의 요소를 onSubscribe 이벤트 발생시에 request 하겠다는 의미입니다.\n2)\nexpectSubscription() 은 생략하고 바로 expectNext(), expectNextCount() 를 사용가능합니다. 다만 onSubscribe 이벤트에 대한 동작을 정의한 Publisher 를 사용중이라면 expectSubscription() 메서드를 꼭 사용해야 올바른 테스트 결과를 얻을 수 있습니다.\ninitialRequest 를 3 으로 지정했기에, 여기에서 5 개의 Flux 내의 item 들 중 3개의 item 들을 처음으로 request 합니다. 그리고 2개가 남아 있는데, 남아있는 2개의 요소는 thenRequest 를 통해 2개의 요소를 request 하고 expectNextCount 구문을 통해 검증을 수행했습니다.\n이렇게 뒤에 남아있는 요소가 있을 때에는 꼭 thenRequest() 또는 thenCancel() 을 통해서 Flux 퍼블리셔를 꼭 종료시켜줘야 합니다.\n3)\ninitialRequest 가 3 인 StepVerifierOptions 를 이용해서 request 했습니다. 이때 첫 subscribe 시 3 개의 요소만 request 한 상태입니다.\n그리고 이 후의 테스트는 데이터의 사이즈가 얼마가 될지 얼마나 클지 확인할수 없는 상황이라고 가정하고 thenCancel() 과 verify() 를 이용해 종료시켜줬습니다.","step#Step":"","step-의-다양한-메서드#Step 의 다양한 메서드":"Step 타입 내에는 as(String description), then(Runnable task), thenRequest(long n) 메서드가 제공됩니다.as(String description)\n이전 step 에 description 을 추가합니다. 테스트 실패시에 as 에 넘겨진 description 이 로그에 나타나게 됩니다.\nthen(Runnable task)\n이전 step 이후(e.g. expectNext, expectNextCount)에 Runnable 코드를 인자로 받아서 실행하는 메서드 입니다.\nthenRequest(long n)\n이전 step 이후(e.g. expectNext, expectNextCount)에 n 만큼의 request 를 수행합니다.\n예제는 위에서 살펴봤던 예제로 대체합니다.e.g.\n@Test\r\npublic void TEST_FIRST_STEP_VERIFIER_OPTIONS(){\r\n    // 1)\r\n    StepVerifierOptions option = StepVerifierOptions.create()\r\n        .initialRequest(3)\r\n        .checkUnderRequesting(false)\r\n        .scenarioName(\"simple 2\");\r\n\r\n    Flux<String> message = Flux.just(\"A\",\"B\",\"C\",\"D\",\"E\");\r\n\r\n    // 2)\r\n    StepVerifier\r\n        .create(message, option)\r\n        .expectSubscription()\r\n        .expectNext(\"A\",\"B\",\"C\").as(\"first\")\r\n        .thenRequest(2)\r\n        .expectNextCount(2).as(\"second\")\r\n        .expectComplete()\r\n        .verify();\r\n\r\n    // 3)\r\n    StepVerifier\r\n        .create(message, option)\r\n        .expectSubscription()\r\n        .expectNext(\"A\",\"B\",\"C\").as(\"first\")\r\n        .thenCancel()\r\n        .verify();\r\n}","onnext#onNext":"StepVerifier 로 테스트를 수행할 때 그 다음 요소들을 검사할 수 있는 메서드를 잘 알고 있어야 테스트 코드 작성이 수월해집니다. 아래는 onNext 이벤트에 대한 기능을 수행하는 Step 내의 메서드 들입니다.\nassertNext : item 의 값을 검증합니다. java 의 Consumer 를 이용해서 assert 문을 수행하는 방식을 ㅗ작성합니다.\nexpectNext : 한개 이상의 item 을 값과 순서를 맞춰서 비교하는 메서드 입니다. 가변 인자를 이용해서 여러개의 값을 받는 것이 가능합니다.\nexpectNextCount (count) : count 에 지정한 수 만큼 onNext 이벤트가 발생하는지를 검증합니다.\nexpectNextSequence : iterable 의 element 들을 onNext 로 전달되는 item 들과 값과 순서를 모두 맞춰 비교합니다.\nexpectNextMatches : onNext 이벤트를 통해 전달된 item 을 비교해서 true/false 를 리턴합니다.\n아래는 예제입니다. 간단하기에 설명은 생략합니다.e.g.\n@Test\r\npublic void TEST_STEP_ON_NEXT_EXAMPLE_1(){\r\n    final Logger log = LoggerFactory.getLogger(WitStepVerifierTest.class);\r\n\r\n    Flux<Integer> numbers = Flux.range(0, 8);\r\n\r\n    StepVerifier.create(numbers)\r\n        .assertNext(number -> {\r\n          Assertions.assertEquals(0, number);\r\n        })\r\n        .expectNext(1,2)\r\n        .expectNextCount(1)  // 3,4,5,6,7 요소 남은 상태.\r\n                                // 5 개의 요소가 남은 상태에서 1개의 onNext 발생하는지 체크. 결과는 true\r\n                                // onNext 1개 소모하게 됨\r\n                                // 4,5,6,7 남음.\r\n        .expectNextSequence(List.of(4,5,6))\r\n        .expectNextMatches(number -> number == 7)\r\n        .expectComplete()\r\n        .verify();\r\n}","context-contextexpectations#Context, ContextExpectations":"StepVerifier 를 이용해서 Flux, Mono 등이 수행되는 퍼블리셔가 수행되는 중인 Context 를 테스트합니다. 코틀린 정리문서 - CoroutineContext 에서도 설명했지만, Context 는 자바의 ThreadLocal 처럼 실행 문맥입니다. 다만 webflux 의 경우 비동기 논블로킹이기 때문에 중간에 실행되는 스레드가 바뀔 수 있습니다. 따라서 Spring Webflux 에서는 ThreadLocal 을 사용이 불가능합니다.webflux 를 이용해서 Publisher 프로그래밍을 작성한다고 하더라도 특정 시점의 실행 문맥에서는 Context 를 통해 값을 공유해야 할 필요가 있습니다. 그렇지 않으면 과도한 flatMap 지옥에 빠질 수 있기 때문입니다.ContextExpectation 은 이러한 Context 를 검증할 때 사용하는 객체입니다.ContextExpectation 에서 제공하는 메서드 들은 아래와 같습니다.\nhasKey(Object key) : Context 내에 특정한 key 가 존재하는지 체크합니다.\nhasSize(int size) : Context 의 size가 특정한 size 가 맞는지 체크합니다.\ncontains(Object key, Object value) : Context 에 특정 key,value 쌍이 존재하는지 체크합니다.\ncontainsAllOf(Context other) : 다른 Context 까지 뒤져서 인자로 전달받은 Map 의 모든 key,value 쌍이 존재하는지 검사합니다.\ncontainsOnly(Context other) : 다른 Context 를 인자로 받아서 이 Context 내의 Key,Value 들이 실제로 현재 Context 내에 모두 존재하는지 검사합니다.\nassertThat(Consumer<Context> consumer) : Consumer 타입의 람다를 통해 Assertion 을 수행합니다.\nmatches(Predicate<Context> predicate) : Context 에 대해 Predicate 를 통해 특정 조건식에 해당하는지 검사를 수행합니다.\nthen() : ContextExpectations 를 종료하고, Step 으로 복귀합니다.\ne.g.\n설명은 생략합니다.\n@Test\r\npublic void CONTEXT_EXAMPLE(){\r\n    // 1)\r\n    Flux<Integer> numbers = Flux.range(0,11);\r\n    StepVerifier.create(numbers)\r\n        .expectNoAccessibleContext()\r\n        .expectNextCount(11)\r\n        .verifyComplete();\r\n\r\n    // 2) Context 를 Flux 에 주입\r\n    Flux<Integer> numbersWithCtx1 = Flux.range(0,11)\r\n        .contextWrite(Context.of(\"Hello\", \"World\"));\r\n    StepVerifier.create(numbersWithCtx1)\r\n        .expectAccessibleContext()\r\n        .contains(\"Hello\", \"World\")\r\n        .then()\r\n        .expectNextCount(11)\r\n        .verifyComplete();\r\n\r\n    // 3) Context 를 StepVerifier 에 주입\r\n    Flux<Integer> numbersWithoutCtx = Flux.range(0,11);\r\n\r\n    var option = StepVerifierOptions.create()\r\n            .withInitialContext(Context.of(\"Hello\", \"World\"));\r\n\r\n    StepVerifier.create(numbersWithoutCtx, option)\r\n        .expectAccessibleContext()\r\n        .contains(\"Hello\", \"World\")\r\n        .then()\r\n        .expectNextCount(11)\r\n        .verifyComplete();\r\n}","laststep#LastStep":"참고 : StepVerifier.java\nLastStep 은 StepVerifier 내에 선언된 내부 interface 이며, 최종 결과를 검증하는 기능들에 많이 쓰입니다.Step<T> 은 LastStep 을 확장(상속)하고 있기에, Step 을 통해서 테스트를 종료시키고 싶을 때 LastStep 의 메서드 들을 호출해서 검증 작업을 마무리합니다.LastStep 에서 제공되는 기능들은 아래와 같습니다.\npublic interface StepVerifier {\r\n    // ...\r\n    \r\n    interface Step<T> extends LastStep {\r\n        // ...\r\n    }\r\n    \r\n\tinterface LastStep {\r\n\t\tStepVerifier consumeErrorWith(Consumer<Throwable> consumer);\r\n\r\n\t\tStepVerifier expectError();\r\n\t\tStepVerifier expectError(Class<? extends Throwable> clazz);\r\n\t\tStepVerifier expectErrorMessage(String errorMessage);\r\n\t\tStepVerifier expectErrorMatches(Predicate<Throwable> predicate);\r\n\t\tStepVerifier expectErrorSatisfies(Consumer<Throwable> assertionConsumer);\r\n\t\tStepVerifier expectTimeout(Duration duration);\r\n\t\tStepVerifier expectComplete();\r\n        \r\n\t\tStepVerifier thenCancel();\r\n\r\n\t\tDuration verifyError();\r\n\t\tDuration verifyError(Class<? extends Throwable> clazz);\r\n\t\tDuration verifyErrorMessage(String errorMessage);\r\n\t\tDuration verifyErrorMatches(Predicate<Throwable> predicate);\r\n\t\tdefault Duration verifyTimeout(Duration duration) {\r\n\t\t\treturn expectTimeout(duration).verify();\r\n\t\t}\r\n        \r\n\t\tDuration verifyErrorSatisfies(Consumer<Throwable> assertionConsumer);\r\n\t\tDuration verifyComplete();\r\n\t}\r\n}","expecterror#expectError**()":"Publisher 가 onError 이벤트를 발생시킬 것으로 보일 때 consumeErrorWith() 또는 expectError**() 메서드를 호출해서 검증을 수행할 수 있습니다.\nconsumeErrorWith() : 전달받은 Consumer 를 이용해서 Consumer 내부에서 검증을 수행합니다.\nexpectError() : onError 이벤트가 전달되었는지 여부를 검증합니다. Class 타입을 전달해서 어떤 타입의 에러가 발생하는지를 검증합니다.\nexpectErrorMessage() : onError 이벤트로 전달된 Error 의 메시지가 원하는 에러 메시지인지 검증합니다.\nexpectErrorMatches() : Exception 에 대한 검증 등을 람다식으로 표현한 Predicate 람다를 이용해서 전달받은 Exception 객체가 올바른지를 검증합니다.\nexpectErrorSatisfies() : consumeErrorWith() 와 동일한 역할을 수행합니다.\npublic interface StepVerifier {\r\n    // ...\r\n    \r\n    interface Step<T> extends LastStep {\r\n        // ...\r\n    }\r\n    \r\n\tinterface LastStep {\r\n\t\tStepVerifier consumeErrorWith(Consumer<Throwable> consumer);\r\n\r\n\t\tStepVerifier expectError();\r\n\t\tStepVerifier expectError(Class<? extends Throwable> clazz);\r\n\t\tStepVerifier expectErrorMessage(String errorMessage);\r\n\t\tStepVerifier expectErrorMatches(Predicate<Throwable> predicate);\r\n\t\tStepVerifier expectErrorSatisfies(Consumer<Throwable> assertionConsumer);\r\n\t\tStepVerifier expectTimeout(Duration duration);\r\n\t\tStepVerifier expectComplete();\r\n        \r\n        // ...\r\n        \r\n\t}\r\n}","eg-expecterror#e.g. expectError**()":"간단한 예제이기에 코드 설명은 건너뛰겠습니다.\n@Test\r\npublic void SIMPLE_EXPECT_ERROR(){\r\n    // 1) 단순 검증\r\n    var errorFlux1 = Flux.error(new IllegalArgumentException());\r\n    StepVerifier.create(errorFlux1)\r\n        .expectError()\r\n        .verify();\r\n\r\n    // 2) 예외 타입 검증\r\n    var errorFlux2 = Flux.error(new IllegalArgumentException());\r\n    StepVerifier.create(errorFlux2)\r\n        .expectError(IllegalArgumentException.class)\r\n        .verify();\r\n\r\n    // 3) 예외 메시지 검증\r\n    String message = \"웁스, 에러에요.\";\r\n    var errorFlux3 = Flux.error(new IllegalArgumentException(message));\r\n    StepVerifier.create(errorFlux3)\r\n        .expectErrorMessage(message)\r\n        .verify();\r\n\r\n    // 4) expectErrorMatches\r\n    String message2 = \"웁스, 에러에요\";\r\n    var errorFlux4 = Flux.error(new IllegalArgumentException(message2));\r\n    StepVerifier.create(errorFlux4)\r\n        .expectErrorMatches(e -> {\r\n          return e instanceof IllegalArgumentException && e.getMessage().equals(message2);\r\n        })\r\n        .verify();\r\n\r\n    // 5) expectErrorSatisfies\r\n    String message3 = \"웁스, 에러네요\";\r\n    var errorFlux5 = Flux.error(new IllegalArgumentException(message3));\r\n    StepVerifier.create(errorFlux5)\r\n        .expectErrorSatisfies(e -> {\r\n          Assertions.assertInstanceOf(IllegalArgumentException.class, e);\r\n          Assertions.assertEquals(message3, e.getMessage());\r\n        })\r\n        .verify();\r\n}","expecttimeout#expectTimeout()":"onNext, onComplete 이벤트가 전달받은 duration 내에 발생하지 않으면 true 로 판단합니다. 특정 duration 이상 소요되는지를 검증합니다.\npublic interface StepVerifier {\r\n    // ...\r\n    \r\n    interface Step<T> extends LastStep {\r\n        // ...\r\n    }\r\n    \r\n\tinterface LastStep {\r\n        // ...\r\n\t\tStepVerifier expectTimeout(Duration duration);\r\n\t}\r\n}","eg-expecttimeout#e.g. expectTimeout()":"//-- expectTimeout\r\n@Test\r\npublic void EXPECT_TIMEOUT_TEST(){\r\n    // 1)\r\n    var publisher1 = Mono.delay(Duration.ofMillis(300));\r\n    StepVerifier.create(publisher1)\r\n        .expectTimeout(Duration.ofMillis(50))\r\n        .verify();\r\n\r\n    // 2) 아래 코드는 에러가 나야 정상인 코드\r\n    //    var publisher2 = Mono.delay(Duration.ofMillis(200));\r\n    //    StepVerifier.create(publisher2)\r\n    //        .expectTimeout(Duration.ofSeconds(1))\r\n    //        .verify();\r\n\r\n    // 3)\r\n    var publisher3 = Flux.range(0, 10)\r\n        .delayElements(Duration.ofMillis(500));\r\n    StepVerifier.create(publisher3)\r\n        .expectTimeout(Duration.ofMillis(100))\r\n        .verify();\r\n}","expectcomplete#expectComplete()":"onComplete 이벤트가 발생함을 검증합니다. verifyComplete() 는 expectComplete(), verify() 메서드를 합친 메서드입니다.\npublic interface StepVerifier {\r\n    // ...\r\n    \r\n    interface Step<T> extends LastStep {\r\n        // ...\r\n    }\r\n    \r\n\tinterface LastStep {\r\n        // ...\r\n        \r\n\t\tStepVerifier expectComplete();\r\n        \r\n        // ...\r\n\t}\r\n}","eg-expectcomplete#e.g. expectComplete()":"@Test\r\npublic void EXPECT_COMPLETE_TEST(){\r\n    // 1)\r\n    var publisher1 = Flux.just(\"Hello\", \"World\", \"Great\");\r\n    StepVerifier.create(publisher1)\r\n        .expectNextCount(3)\r\n        .expectComplete()\r\n        .verify();\r\n\r\n    // 2) 아래 코드는 Exception 이 발생하는 코드에 대해 expectError** 을 하지 않았으므로 에러가 발생합니다.\r\n    //    var publisher2 = Flux.error(new IllegalArgumentException());\r\n    //    StepVerifier.create(publisher2)\r\n    //        .expectComplete()\r\n    //        .verify();\r\n}","thencancel#thenCancel()":"Publisher 를 통해 이벤트를 처리하는 도중에 thenCancel 이벤트를 호춣해서 Subscribe 하는 동작을 cancel 하는 것 역시 가능합니다. Subscription.cancel() 을 호출하는 것과 동일한 동작입니다.\npublic interface StepVerifier {\r\n    // ...\r\n    \r\n    interface Step<T> extends LastStep {\r\n        // ...\r\n    }\r\n    \r\n\tinterface LastStep {\r\n\t\t// ...\r\n        \r\n\t\tStepVerifier thenCancel();\r\n\r\n\t\t// ...\r\n\t}\r\n}","eg-thencancel#e.g. thenCancel()":"@Test\r\npublic void THEN_CANCEL(){\r\n    var publisher = Flux.range(1, Integer.MAX_VALUE)\r\n        .doOnNext(number -> System.out.println(\"안녕하세요\"));\r\n\r\n    StepVerifier.create(publisher)\r\n        .expectNextCount(2)\r\n        .thenCancel()\r\n        .verify();\r\n}","verify#verify...()":"verify...() 메서드는 아래와 같은 의미입니다. expect...() 메서드 뒤에 verify() 를 붙이는 것의 축약형식으로 제공되는 메서드 입니다.\nverifyComplete() : expectComplete() + verify()\nverifyError() : expectError() + verify()\nverifyErrorMessages() : expectErrorMessages() + verify()\nverifyErrorMatches() : expectErrorMatches() + verify()\nverifyErrorSatisfies() : expectErrorSatisfies() + verify()\npublic interface StepVerifier {\r\n    // ...\r\n    \r\n    interface Step<T> extends LastStep {\r\n        // ...\r\n    }\r\n    \r\n\tinterface LastStep {\r\n        // ...\r\n\t\tDuration verifyError();\r\n\t\tDuration verifyError(Class<? extends Throwable> clazz);\r\n\t\tDuration verifyErrorMessage(String errorMessage);\r\n\t\tDuration verifyErrorMatches(Predicate<Throwable> predicate);\r\n\t\tdefault Duration verifyTimeout(Duration duration) {\r\n\t\t\treturn expectTimeout(duration).verify();\r\n\t\t}\r\n        \r\n\t\tDuration verifyErrorSatisfies(Consumer<Throwable> assertionConsumer);\r\n\t\tDuration verifyComplete();\r\n\t}\r\n}","withvirtualtime#withVirtualTime":"","testpublisher#TestPublisher":""}},"/mockito-test":{"title":"Mockito Test","data":{"mockito-테스트#Mockito 테스트":""}},"/slice-test":{"title":"Slice Test","data":{"슬라이스-테스트-slice-test#슬라이스 테스트 (Slice Test)":""}},"/reactor-test":{"title":"Reactor Test","data":{"reactor-테스트#Reactor 테스트":""}},"/test-tips":{"title":"Test Tips","data":{"테스트-tips#테스트 Tips":"Private 메서드 테스트\nTest 객체 생성\nTest Double 이 뭐에요?"}},"/test-tips/private-method-test":{"title":"Private Method Test","data":{"private-메서드-테스트#Private 메서드 테스트":""}},"/test-tips/test-fixtures":{"title":"Test Fixtures","data":{"테스트-더미-객체-생성#테스트 더미 객체 생성":""}},"/test-tips/what-is-test-double":{"title":"What Is Test Double","data":{"test-double-이-뭔가요#Test Double 이 뭔가요?":""}},"/unit-test":{"title":"Unit Test","data":{"유닛-테스트-unit-test#유닛 테스트 (Unit Test)":""}},"/unit-test/assertj-assertions":{"title":"Assertj Assertions","data":{"assertions-assertj#Assertions (Assertj)":""}},"/unit-test/assumption":{"title":"Assumption","data":{"assumption-junit-jupiter#Assumption (Junit Jupiter)":""}},"/unit-test/junit-jupiter":{"title":"Junit Jupiter","data":{"junit-jupiter#JUnit Jupiter":""}},"/unit-test/what-is-unit-test":{"title":"What Is Unit Test","data":{"단위-테스트의-개념-원칙-목적#단위 테스트의 개념, 원칙, 목적":"","단위테스트란#단위테스트란?":"참고 : ko.wikipedia.org/wiki - 유닛테스트\n단위 테스트는 단위테스트 또는 유닛테스트라고 불립니다. ko.wikipedia.org/wiki - 유닛테스트 에서는 아래와 같이 단위테스트를 설명하고 있습니다.\n컴퓨터 프로그래밍에서 소스 코드의 특정 모듈이 의도된 대로 정확히 작동하는지 검증하는 절차\n즉, 모든 함수와 메소드에 대한 테스트 케이스(Test case)를 작성하는 절차\n이를 통해서 언제라도 코드 변경으로 인해 문제가 발생할 경우, 단시간 내에 이를 파악하고 바로 잡을 수 있는 것이 가능해짐\n이상적으로, 각 테스트 케이스는 서로 분리되어야 한다.\n이를 위해 가짜 객체(Mock object)를 생성하는 것도 좋은 방법\n예를 들어 아래와 같은 코드가 있다고 해보겠습니다.\n// ...\r\nprivate final CommentService commentService;\r\nprivate final CommentCntService commentCntService;\r\n// ...\r\n\r\nprivate final CleanPlatformFeignClient cleanPlatformClient;\r\n\r\n@Transactional\r\npublic void createComment(CommentCreateRequest request){\r\n    // ...\r\n    \r\n    // 1) \r\n    var response = cleanPlatformClient.fetchApi(url, payload);\r\n    \r\n    // 2)\r\n    if(response.isOk()){\r\n        // 3)\r\n        commentService.save(request);\r\n        \r\n        // 4)\r\n        commentCntService.save(request);\r\n    }\r\n    else{\r\n        throw new BadCommentCreateTryException(request);\r\n    }\r\n    \r\n}\n단위테스트는 위 코드에서 1), 2), 3), 4) 메서드 각각에 대한 테스트 케이스들을 만드는 것을 의미합니다. 그리고 1), 2), 3), 4) 내에도 세부적인 메서드 콜이 있다면 그 메서드가 수행하는 동작에 대한 단위 기능에 대한 테스트 케이스를 작성합니다.이때 하나의 단위 기능에서 여러가지 역할을 수행한다면 단위테스트가 모호해집니다. 단위 테스트 기반으로 코드를 작성하게 되면, 하나의 기능은 하나의 역할을 한다, 하나의 기능이 변경되는 이유는 하나의 이유로 변경되어야 한다는 SRP 원칙을 지킨 코드가 되도록 작성하기 수월해지게 됩니다.1) 의 코드는 Mocking 기반으로 실행해야 합니다. 외부 API의 경우에는 외부 API 내부의 요건에 따라 항상 같은 값을 돌려받을 수 있다는 보장이 없기에 테스트 코드에서는 Mocking 기반으로 작성해야 합니다.","first-원칙#FIRST 원칙":"클린 코드의 저자 Robert Martin 이 제시하는 규칙입니다. 효과적인 테스트를 위한 5가지 원칙을 제시하는데, 아래와 같습니다.\nF : Fast\nI : Isolated (or Independent)\nR : Repeatable\nS : Self-Validating\nT : Timely\nF : Fast단위 테스트는 빠르게 실행되어야 한다는 원칙입니다.단위 테스트는 여러가지 경우에 대해 다양한 경우를 테스트하기에 테스트의 속도가 빠를 수록 개발자들이 더 자주 테스트를 실행해서 코드를 수정하고 피드백을 받을 수 있도록 돕습니다.I : Isolated (or Independent)단위 테스트는 독립적으로 수행되어야 합니다. 하나의 테스트가 다른 테스트에 영향을 주지 않고 독립적으로 실행될 수 있어야 합니다.외부 API 호출, 메시지 큐 데이터 Consumer 동작은 단위테스트 코드 내에서는 Mocking 을 기반으로 작성해야 합니다.R : Repeatable단위테스트는 어떤 환경에서도 반복실행을 하더라도 같은 입력값에 대해 같은 결과값을 리턴해야 합니다. 이렇게 같은 입력에 대해 같은 결과값을 리턴하면 테스트가 신뢰할 수 있고 안정적으로 실행될 수 있음을 보장할 수 있게 됩니다.S : Self-validating단위 테스트는 수동으로 결과를 확인할 필요 없이 자동으로 실행될 수 있어야 하며, 테스트의 성공, 실패 여부를 테스트 코드 자체를 통해서 명확히 판단이 가능해야 합니다.또한 결과가 애매한 상황이 없어야 합니다.T : Timely테스트는 적절한 시점에 작성되어야 합니다. 코드의 변경사항이 발생하면, 테스트 코드도 함께 변경해서 일관된 상태를 유지하게끔 해야 합니다. 이렇게 항상 일관된 상태를 유지하게끔 하면 신뢰성, 유지보수성이 향상되게 됩니다."}},"/unit-test/jupiter-assertions":{"title":"Jupiter Assertions","data":{"assertions-junit-jupiter#Assertions (Junit Jupiter)":"","asserttrue-assertfalse#assertTrue, assertFalse":"// 1)\r\n@Test\r\npublic void ASSERT_TRUE_FALSE_SIMPLE(){\r\n    boolean someTrue = true;\r\n    Assertions.assertTrue(someTrue);\r\n\r\n    boolean someFalse = false;\r\n    Assertions.assertFalse(someFalse);\r\n}\r\n\r\n// 2)\r\n@Test\r\npublic void ASSERT_TRUE_FALSE_SUPPLIER(){\r\n    Assertions.assertTrue(()-> {\r\n        return true;\r\n    });\r\n}\n1)\n값 기반으로 Assert 를 합니다.\n2)\nSupplier 에 대한 Assert 를 수행합니다.\n예를 들면 Spring Cloud Function 등을 사용할 경우 단순 값이 아닌 Supplier 를 리턴하는 경우도 꽤 많은데, 이런 경우 Supplier 를 그대로 넘겨주어서 assert 를 수행하는 것이 가능합니다.","assertequals-assertnotequals#assertEquals, assertNotEquals":"값을 비교하는 Assertion 입니다.\n// 1)\r\n@Test\r\npublic void ASSERT_EQUALS_NOT_EQUALS_1(){\r\n    String s1 = \"HELLO\";\r\n    String s2 = \"HELLO\";\r\n    Assertions.assertEquals(s1, s2);\r\n}\r\n\r\npublic class Message{\r\n    private String payload;\r\n    public Message(String payload){\r\n      this.payload = payload;\r\n    }\r\n}\r\n\r\n// 2)\r\n@Test\r\npublic void ASSERT_EQUALS_NOT_EQUALS_2(){\r\n    Message m1 = new Message(\"111\");\r\n    Message m2 = new Message(\"222\");\r\n    Assertions.assertNotEquals(m1, m2);\r\n}\n1)\ns1, s2 를 비교합니다. String 내에는 equals() 메서드가 정의되어 있기 때문에 s1, s2 를 Assertions.assertEquals() 로 비교 시에 같은 값으로 판단됩니다.\n2)\nm1, m2 를 비교합니다. Message 내에는 equals() 메서드가 정의되어 있지 않기 때문에 m1, m2 를 Assert.assertNotEquals() 로 비교시 참으로 인식됩니다.","assertsame-assertnotsame#assertSame, assertNotSame":"assertSame(), assertNotSame() 의 비교는 값의 비교가 아닌 참조의 비교를 수행합니다.\npublic class Box{\r\n    int weight;\r\n    public Box(int weight){\r\n      this.weight = weight;\r\n    }\r\n    @Override\r\n    public boolean equals(Object o) {\r\n      if (this == o) {\r\n        return true;\r\n      }\r\n      if (o == null || getClass() != o.getClass()) {\r\n        return false;\r\n      }\r\n      Box box = (Box) o;\r\n      return weight == box.weight;\r\n    }\r\n}\r\n\r\n@Test\r\npublic void ASSERT_SAME_NOT_SAME(){\r\n    // 1) \r\n    Box b1 = new Box(10);\r\n    Box b2 = new Box(10);\r\n    Assertions.assertNotSame(b1, b2);\r\n    Assertions.assertEquals(b1, b2);\r\n\r\n    // 2)\r\n    String s1 = \"Hello\";\r\n    Supplier<String> lazyS2 = () -> s1;\r\n    Assertions.assertSame(s1, lazyS2.get());\r\n}\n1)\nb1, b2 비교시 Box 클래스 내에는 equals() 메서드가 정의되어 있기에 assertEquals(b1, b2) 의 결과는 true 이며, 참조값의 비교시 b1, b2 는 서로 다른 메모리 참조값을 가지기에 assertNotSame(b1, b2) 를 통해 b1, b2 의 메모리 주소가 다르다는 것을 확인가능합니다.\n똑같은 s1 변수를 리턴하는 assert 입니다. assertSame() 은 메모리 참조를 비교하기 때문에 assertSame(s1, lazyS2.get()) 의 결과는 true 입니다.","assertarrayequals-assertiterableequals#assertArrayEquals, assertIterableEquals":"배열 또는 Iterable 타입에 대해 값의 비교를 확인해봅니다.\n@Test\r\npublic void ASSERT_ARRAY_EQUALS_AND_ITERABLE_EQUALS(){\r\n    // 1)\r\n    String [] actualArray = {\"A\", \"B\", \"C\"};\r\n    String [] expectedArray = {\"A\", \"B\", \"C\"};\r\n    Assertions.assertArrayEquals(actualArray, expectedArray);\r\n\r\n    // 2)\r\n    List<String> actualList = List.of(\"A\",\"B\",\"C\");\r\n    List<String> expectedList = List.of(\"A\",\"B\",\"C\");\r\n    Assertions.assertIterableEquals(actualList, expectedList);\r\n}\n1)\nactualArray 와 expectedArray 는 각 요소의 순서, 값 모두 일치합니다.\n2)\nactualList 와 expectedList 모두 각 요소의 순서, 값 모두 일치합니다.","assertlinesmatch#assertLinesMatch":"assertLinesMatch 는 두개의 스트림의 모든 요소가 순서와 값이 모두 일치하거나, 두개의 리스트의 모든 요소가 순서와 값이 모두 일치하는 경우를 테스트할 때 사용합니다.\n@Test\r\npublic void ASSERT_LINES_MATCH(){\r\n    // 1)\r\n    Stream<String> sourceStream = Stream.of(\"A\", \"B\", \"C\");\r\n    Stream<String> targetStream = Stream.of(\"A\", \"B\", \"C\");\r\n    Assertions.assertLinesMatch(sourceStream, targetStream);\r\n\r\n    // 2)\r\n    List<String> sourceList = List.of(\"A\", \"B\", \"C\");\r\n    List<String> targetList = List.of(\"A\", \"B\", \"C\");\r\n    Assertions.assertLinesMatch(sourceList, targetList);\r\n}\n1)\nStream 내의 모든 요소의 순서와 값이 일치하기에 테스트가 실패하지 않습니다.\n2)\nList 내의 모든 요소의 순서와 값이 일치하기에 테스트가 실패하지 않습니다.","assertnull-assertnotnull#assertNull, assertNotNull":"Null 인지, Null 이 아닌지를 검사합니다. 간단한 예제이기에 설명은 생략합니다.\n@Test\r\npublic void ASSERT_NULL_NOT_NULL(){\r\n    String nullStr = null;\r\n    Assertions.assertNull(nullStr);\r\n\r\n    String apple = \"APPLE\";\r\n    Assertions.assertNotNull(apple);\r\n}","assertinstanceof#assertInstanceOf":"특정 타입에 해당하는지 검사합니다.\n@Test\r\npublic void ASSERT_INSTANCE_OF(){\r\n    var exception = new RuntimeException(\"어머, 예외가 발생했어요.\");\r\n    Assertions.assertInstanceOf(RuntimeException.class, exception);\r\n}","fail#fail":"특정 케이스에 테스트를 실패시켜야 할 경우 Assert.fail() 을 방출하도록 합니다. 유지보수로 인해 생긴 변경에 대한 테스트 케이스를 수정해야 함을 파악하기에 좋은 방식입니다.\n@Test\r\npublic void ASSERT_FAIL(){\r\n    Logger log = LoggerFactory.getLogger(JUnitAssertionsTest.class);\r\n    var exception = new RuntimeException(\"어머, 예외가 발생했어요.\");\r\n\r\n    if(exception != null)\r\n      Assertions.fail();\r\n    else{\r\n      log.info(\"예외가 발생하지 않았어요. 정상이에요.\");\r\n    }\r\n}\r\n\r\n@Test\r\npublic void ASSERT_TEST_MUST_FAIL(){\r\n    Logger log = LoggerFactory.getLogger(JUnitAssertionsTest.class);\r\n    var exception = new RuntimeException(\"어머, 예외가 발생했어요.\");\r\n\r\n    if(exception != null)\r\n      Assertions.fail(exception);\r\n    else{\r\n      log.info(\"예외가 발생하지 않았어요. 정상이에요.\");\r\n    }\r\n}","assertall#assertAll":"특정 단언문들을 한꺼번에 실행하고 싶을때가 있습니다. 또는 즉시 로딩하는 연산대신 lazy loading 을 하는 연산을 수행하고 싶을 경우가 있습니다. 이런 경우 junit.jupiter 의 Executable 을 활용해서 아래와 같이 Assertions.assertAll(Executable executables...) 을 수행하면 됩니다.\n@Test\r\npublic void ASSERT_ALL(){\r\n    Assertions.assertAll(\r\n        () -> {Assertions.assertTrue(true);},\r\n        () -> {Assertions.assertTrue(1 > 0);},\r\n        () -> {Assertions.assertTrue(List.of(1,2,3).size() == 3);}\r\n    );\r\n\r\n    Stream<Executable> stream = Stream.of(\r\n        () -> {Assertions.assertTrue(true);},\r\n        () -> {Assertions.assertTrue(1 > 0);},\r\n        () -> {Assertions.assertTrue(List.of(1,2,3).size() == 3);}\r\n    );\r\n    Assertions.assertAll(stream);\r\n}","assertthrows-assertthrowsexactly#assertThrows, assertThrowsExactly":"특정 비즈니스 로직의 유효성 체크나, 요건이 성립하지 않는 경우를 테스트하기 위해 Exception 을 내는 테스트 케이스를 해야 할 경우가 많습니다. 또한 비즈니스 로직에 따라서 Exception 의 종류도 다양하게 정의하고 여러 가지 경우의 수로 나누어서 여러가지 Exception 을 throw 합니다. 이런 경우에 대한 테스트는 assertThrows, assertThrowsExactly 를 사용합니다.\n@Test\r\npublic void ASSERT_THROWS_ASSERT_THROWS_EXACTLY(){\r\n    Assertions.assertThrows(\r\n        IllegalStateException.class,\r\n        () -> {\r\n          throw new IllegalStateException(\"예외가 발생했어요\");\r\n        }\r\n    );\r\n\r\n    Assertions.assertThrows(\r\n        RuntimeException.class, // IllegalArgumentException 은 RuntimeException 의 한 종류로 판단\r\n        () -> {\r\n          throw new IllegalStateException(\"예외가 발생했어요\");\r\n        }\r\n    );\r\n\r\n    /** 테스트가 실패합니다.\r\n     * RuntimeException 은 IllegalStateException 의 상위타입입니다.\r\n    Assertions.assertThrows(\r\n        IllegalStateException.class,\r\n        () -> {\r\n          throw new RuntimeException(\"asdf\");\r\n        }\r\n    );\r\n    */\r\n\r\n    Assertions.assertThrowsExactly(\r\n        IllegalStateException.class,\r\n        () -> {\r\n          throw new IllegalStateException(\"예외가 발생했어요\");\r\n        }\r\n    );\r\n\r\n    /** 테스트가 실패합니다.\r\n     * IllegalStateException RuntimeException 의 한 종류이지만,\r\n     * Assertions.assertThrowsExactly 는 정확하게 타입이 일치해야만 성공으로 인식합니다.\r\n    Assertions.assertThrowsExactly(\r\n        RuntimeException.class,\r\n        () -> {\r\n          throw new IllegalStateException(\"예외가 발생했어요\");\r\n        }\r\n    );\r\n    */\r\n}","assertdoesnotthrow#assertDoesNotThrow":"Exception 이 발생하지 않음을 보장합니다.\n@Test\r\npublic void ASSERT_DOES_NOT_THROW(){\r\n    Assertions.assertDoesNotThrow(\r\n        () -> {}\r\n    );\r\n\r\n    Assertions.assertDoesNotThrow(\r\n        () -> \"안녕하세요\"\r\n    );\r\n}","asserttimeout#assertTimeout":"@Test\r\npublic void ASSERT_TIMOUT(){\r\n    final Duration timeLimit = Duration.ofSeconds(1);\r\n\r\n    Assertions.assertTimeout(timeLimit, () -> {\r\n      sleep(500);\r\n    });\r\n\r\n    var externalResult = Assertions.assertTimeout(timeLimit, () -> {\r\n      sleep(500);\r\n      return true;\r\n    });\r\n    Assertions.assertTrue(externalResult);\r\n\r\n    /** 실패하는 케이스 : 미리 지정한 1초의 타임아웃을 넘어서는 케이스\r\n    Assertions.assertTimeout(timeLimit, () -> {\r\n      sleep(2000);\r\n    });\r\n    */\r\n}\r\n\r\npublic void sleep(long ms){\r\n    try{\r\n      Thread.sleep(ms);\r\n    }\r\n    catch (Exception e){\r\n      e.printStackTrace();\r\n    }\r\n}","asserttimeoutpreemptively#assertTimeoutPreemptively":"참고자료 : Junit5 Assertions/Assumptions 설명\n예를 들어 아래의 코드는 10초동안 기다려야 테스트가 끝납니다.\npublic void sleep(long ms){\r\n    try{\r\n      Thread.sleep(ms);\r\n    }\r\n    catch (Exception e){\r\n      e.printStackTrace();\r\n    }\r\n}\r\n\r\n@Test\r\npublic void ASSERT_TIMEOUT_NO_PREEMPTIVELY(){\r\n    final Duration timeLimit = Duration.ofSeconds(8);\r\n\r\n    var externalResult = Assertions.assertTimeout(timeLimit, () -> {\r\n      sleep(7000);\r\n      return true;\r\n    });\r\n    Assertions.assertTrue(externalResult);\r\n}\n위의 테스트 코드를 1초 동안만 기다렸다가, 1초 내에 테스트가 끝나지 않으면 종료시키려 할 경우 아래와 같이 작성합니다. 아래 코드는 익셉션을 내면서 종료됩니다.\n@Disabled\r\n@TestMustFail\r\npublic void ASSERT_TIMEOUT_PREEMPTIVELY(){\r\n    final Duration timeLimit = Duration.ofSeconds(1);\r\n\r\n    var externalResult = Assertions.assertTimeoutPreemptively(timeLimit, () -> {\r\n      sleep(7000);\r\n      return true;\r\n    });\r\n    Assertions.assertTrue(externalResult);\r\n}\r\n\r\n// @TestMustFail 은 아래와 같이 정의해두었습니다.\r\n@Target(ElementType.METHOD)\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@Test\r\npublic @interface TestMustFail {\r\n\r\n}\nassertTimeoutPreemptively 를 사용하면 오래 걸리는 작업이 정해둔 타임아웃 내에 끝나지 않으면 작업을 종료시킵니다. 이 과정에서 익셉션이 발생하기도 합니다. assertTimeoutPreemptively 는 독립적인 스레드로 실행하는데, 트랜잭션이 포함되어 있는 경우 트랜잭션 스레드와는 별개로 수행되어서 롤백이 안되는 경우가 생길 수 있습니다.오래 걸리는 작업인데, 결과값의 검증이 필요한 경우 assertTimeoutPreemptively 보다는 assertTimeout 을 사용하는 것이 낫습니다.\n무조건 사용을 안할 수는 없겠지만, 익셉션이 발생할 수도 있는 통신에 대한 환경 테스트가 필요한 경우 (e.g. 테스트 환경에서 특정 외부 API가 네트워크 접속이 되는지와 같은 테스트 전제 조건을 체크해야 할 경우) 에는 사용할수도 있는 아주 드문 케이스 중 하나입니다."}},"/unit-test/test-libraries":{"title":"Test Libraries","data":{"다양한-테스트-라이브러리#다양한 테스트 라이브러리":"JUnit5\nJUnit 5 User Guide\nAssertion, Assumption 라이브러리\nAssertJ\nJUnit5 Assertions\nJUnit5 Assumptions\nHamcrest\nTruth\nMockito Framework\nTestContainers"}},"/what-is-software-test":{"title":"What Is Software Test","data":{"소프트웨어-테스트란#소프트웨어 테스트란?":"참고 : ko.wikipedia.org/wiki - 소프트웨어 테스트\n소프트웨어 테스트는 주요 이해관계자들에게 시험 대상 제품, 서비스 품질에 대한 정보를 제공하는 조사과정입니다.소프트웨어 테스트는 아래의 특징들을 제공합니다.\n소프트웨어에 대한 객관적이고 독립적인 시각을 제공\n사업 주체가 소프트웨어 구현의 위험성을 올바로 이해할 수 있도록 도움을 제공","소프트웨어-테스트의-7가지-원칙#소프트웨어 테스트의 7가지 원칙":"참고: ISTQB Foundation Level - Seven testing Principles\nISTQB 에서 정의하는 소프트웨어의 7가지 원칙은 아래와 같습니다.\nTesting shows the presence of defects, not their absence\n테스트는 결함의 부재가 아닌, 결함의 존재를 보여줘야 합니다.\n테스트를 통해 소프트웨어의 결함을 확인할 수 있습니다.\nExhaustive testing is impossible\n완벽한 테스트는 불가능합니다.\nEarly testing saves time and money\n일찍 진행한 테스트는 비용을 줄여줍니다.\nDefects cluster together\n결함은 집중되고 군집(클러스터)되는 경향이 있습니다.\nBeware of the pesticide paradox\n살충제 패러독스에 빠지지 않도록 해야합니다.\nTesting is context-dependent\n테스트는 주변 환경에 의존적입니다.\nAbsence-of-errors is a fallacy\n오류가 없다는 것은 오류입니다.","testing-shows-the-presence-of-defects-not-their-absence#Testing shows the presence of defects, not their absence":"테스트는 결함의 부재가 아닌, 결함의 존재를 보여줘야 합니다.\n테스트를 통해 소프트웨어의 결함을 확인할 수 있다.\n테스트는 소프트웨어의 결함을 찾기 위한 과정이며, 소프트웨어에 결함이 있다는 것을 보여주는 과정입니다. 테스트는 결함을 찾아가는 과정이며, 완전하게 오류가 없음을 보장하지는 않습니다. 다만 일정 수준의 테스트를 통해서 소프트웨어의 정상 작동 범위를 보장할 수 있고 신뢰성을 높일 수 있습니다.","exhaustive-testing-is-impossible#Exhaustive testing is impossible":"완벽한 테스트는 불가능합니다.\n모든 입력, 전제조건들을 일일이 테스트하는 것은 실제로는 불가능합니다. 테스트에 필요한 인적, 시간적 리소스는 한정적입니다. 따라서 필요한 기능과 정합성이 보장되어야 하는 요소를 적절하게 선정해서 테스트를 적용해야 합니다.","early-testing-saves-time-and-money#Early testing saves time and money":"일찍 진행한 테스트는 비용을 줄여줍니다.\n테스트는 일찍 진행할 수록 비용이 줄어듭니다. 요구사항 수립, 개발작업 사이에 먼저 테스트를 통해 발견한 버그는 QA 시에 발생하는 시간적, 인적 리소스를 줄여줍니다.","defects-cluster-together#Defects cluster together":"결함은 집중되고 군집(클러스터)되는 경향이 있습니다.\n결함은 특정 요소에 클러스터처럼 퍼져있는 경우가 많습니다.","beware-of-the-pesticide-paradox#Beware of the pesticide paradox":"살충제 패러독스에 빠지지 않도록 해야합니다.\n시간이 지남에 따라 동일한 테스트 케이스를 반복해서 수행하는 것은 지양해야 합니다. 동일한 테스트를 반복하면, 소프트웨어가 정상적으로 수행되는 것은 확인이 가능하지만, 새로운 문제는 발견해내지 못합니다.테스트를 정기적으로 업데이트하고 검토하면서 테스트를 개선시켜나가야 합니다.","testing-is-context-dependent#Testing is context-dependent":"테스트는 주변 환경에 의존적입니다.\n테스트는 주변 환경에 따라서 완전히 달라질 수 있습니다. 프로젝트 마다 요구되는 주변 상황, 환경 등을 고려해서 테스트의 환경을 커스터마이징해야 합니다. 예를 들면 증권 시세 데이터서비스와 원장 서비스는 환경이 다릅니다. 각각의 환경에 맞는 테스트 환경을 수립해야 합니다.","absence-of-errors-is-a-fallacy#Absence-of-errors is a fallacy":"오류가 없다는 것은 오류입니다.\n소프트웨어에 결함이 없다는 것이 단순히 소프트웨어에 결함이 없다는 것을 보장하지는 않습니다. 테스트의 목표를 100% 결함을 찾아내는 것에 목적을 두기보다 사용자에게 제공되는 기능이 올바른지를 검증하는 데에 목적을 두어야 합니다.","테스트의-목적#테스트의 목적":"테스트의 장점은 버그를 검증하거나, 특정 조건 내에서 이 기능이 꼭 성공함을 보장한다거나 특정 기능의 명세는 이런 요구사항을 가짐을 명세화할 경우 테스트는 장점을 가집니다. 완벽한 결함 제거 보다는 꼭 성공해야 하는 필수적인 기능에 대해 기능의 검증을 반복해서 자동화 기반으로 검증할 수 있다면 좋습니다.","테스트의-종류#테스트의 종류":"테스트의 종류는 단위테스트, 슬라이스테스트, 통합테스트가 있습니다. 이번 github 페이지에서는 이 내용들을 다룹니다."}}}