{"/":{"title":"Introduction","data":{"":"JUnit Jupiter 기반 단위테스트\nMockito 기반 다양한 단위테스트\nSpring Reactive 에서의 테스트\n슬라이스 테스트 (Web, Data)\n통합 테스트"}},"/slice-test":{"title":"Slice Test","data":{"슬라이스-테스트-slice-test#슬라이스 테스트 (Slice Test)":""}},"/unit-test":{"title":"Unit Test","data":{"유닛-테스트-unit-test#유닛 테스트 (Unit Test)":""}},"/unit-test/assertions":{"title":"Assertions","data":{"assrtions-junit-jupiter#Assrtions (Junit Jupiter)":""}},"/unit-test/assumption":{"title":"Assumption","data":{"assumption-junit-jupiter#Assumption (Junit Jupiter)":""}},"/unit-test/junit-jupiter":{"title":"Junit Jupiter","data":{"junit-jupiter#JUnit Jupiter":""}},"/unit-test/what-is-unit-test":{"title":"What Is Unit Test","data":{"단위-테스트의-개념-원칙-목적#단위 테스트의 개념, 원칙, 목적":"","단위테스트란#단위테스트란?":"참고 : ko.wikipedia.org/wiki - 유닛테스트\n단위 테스트는 단위테스트 또는 유닛테스트라고 불립니다. ko.wikipedia.org/wiki - 유닛테스트 에서는 아래와 같이 단위테스트를 설명하고 있습니다.\n컴퓨터 프로그래밍에서 소스 코드의 특정 모듈이 의도된 대로 정확히 작동하는지 검증하는 절차\n즉, 모든 함수와 메소드에 대한 테스트 케이스(Test case)를 작성하는 절차\n이를 통해서 언제라도 코드 변경으로 인해 문제가 발생할 경우, 단시간 내에 이를 파악하고 바로 잡을 수 있는 것이 가능해짐\n이상적으로, 각 테스트 케이스는 서로 분리되어야 한다.\n이를 위해 가짜 객체(Mock object)를 생성하는 것도 좋은 방법\n예를 들어 아래와 같은 코드가 있다고 해보겠습니다.\n// ...\r\nprivate final CommentService commentService;\r\nprivate final CommentCntService commentCntService;\r\n// ...\r\n\r\nprivate final CleanPlatformFeignClient cleanPlatformClient;\r\n\r\n@Transactional\r\npublic void createComment(CommentCreateRequest request){\r\n    // ...\r\n    \r\n    // 1) \r\n    var response = cleanPlatformClient.fetchApi(url, payload);\r\n    \r\n    // 2)\r\n    if(response.isOk()){\r\n        // 3)\r\n        commentService.save(request);\r\n        \r\n        // 4)\r\n        commentCntService.save(request);\r\n    }\r\n    else{\r\n        throw new BadCommentCreateTryException(request);\r\n    }\r\n    \r\n}\n단위테스트는 위 코드에서 1), 2), 3), 4) 메서드 각각에 대한 테스트 케이스들을 만드는 것을 의미합니다. 그리고 1), 2), 3), 4) 내에도 세부적인 메서드 콜이 있다면 그 메서드가 수행하는 동작에 대한 단위 기능에 대한 테스트 케이스를 작성합니다.이때 하나의 단위 기능에서 여러가지 역할을 수행한다면 단위테스트가 모호해집니다. 단위 테스트 기반으로 코드를 작성하게 되면, 하나의 기능은 하나의 역할을 한다, 하나의 기능이 변경되는 이유는 하나의 이유로 변경되어야 한다는 SRP 원칙을 지킨 코드가 되도록 작성하기 수월해지게 됩니다.1) 의 코드는 Mocking 기반으로 실행해야 합니다. 외부 API의 경우에는 외부 API 내부의 요건에 따라 항상 같은 값을 돌려받을 수 있다는 보장이 없기에 테스트 코드에서는 Mocking 기반으로 작성해야 합니다.","first-원칙#FIRST 원칙":"클린 코드의 저자 Robert Martin 이 제시하는 규칙입니다. 효과적인 테스트를 위한 5가지 원칙을 제시하는데, 아래와 같습니다.\nF : Fast\nI : Isolated (or Independent)\nR : Repeatable\nS : Self-Validating\nT : Timely\nF : Fast단위 테스트는 빠르게 실행되어야 한다는 원칙입니다.단위 테스트는 여러가지 경우에 대해 다양한 경우를 테스트하기에 테스트의 속도가 빠를 수록 개발자들이 더 자주 테스트를 실행해서 코드를 수정하고 피드백을 받을 수 있도록 돕습니다.I : Isolated (or Independent)단위 테스트는 독립적으로 수행되어야 합니다. 하나의 테스트가 다른 테스트에 영향을 주지 않고 독립적으로 실행될 수 있어야 합니다.외부 API 호출, 메시지 큐 데이터 Consumer 동작은 단위테스트 코드 내에서는 Mocking 을 기반으로 작성해야 합니다.R : Repeatable단위테스트는 어떤 환경에서도 반복실행을 하더라도 같은 입력값에 대해 같은 결과값을 리턴해야 합니다. 이렇게 같은 입력에 대해 같은 결과값을 리턴하면 테스트가 신뢰할 수 있고 안정적으로 실행될 수 있음을 보장할 수 있게 됩니다.S : Self-validating단위 테스트는 수동으로 결과를 확인할 필요 없이 자동으로 실행될 수 있어야 하며, 테스트의 성공, 실패 여부를 테스트 코드 자체를 통해서 명확히 판단이 가능해야 합니다.또한 결과가 애매한 상황이 없어야 합니다.T : Timely테스트는 적절한 시점에 작성되어야 합니다. 코드의 변경사항이 발생하면, 테스트 코드도 함께 변경해서 일관된 상태를 유지하게끔 해야 합니다. 이렇게 항상 일관된 상태를 유지하게끔 하면 신뢰성, 유지보수성이 향상되게 됩니다."}},"/integration-test":{"title":"Integration Test","data":{"통합-테스트-integration-test#통합 테스트 (Integration Test)":""}},"/reactor-test":{"title":"Reactor Test","data":{"reactor-테스트#Reactor 테스트":""}},"/what-is-software-test":{"title":"What Is Software Test","data":{"소프트웨어-테스트란#소프트웨어 테스트란?":"참고 : ko.wikipedia.org/wiki - 소프트웨어 테스트\n소프트웨어 테스트는 주요 이해관계자들에게 시험 대상 제품, 서비스 품질에 대한 정보를 제공하는 조사과정입니다.소프트웨어 테스트는 아래의 특징들을 제공합니다.\n소프트웨어에 대한 객관적이고 독립적인 시각을 제공\n사업 주체가 소프트웨어 구현의 위험성을 올바로 이해할 수 있도록 도움을 제공","소프트웨어-테스트의-7가지-원칙#소프트웨어 테스트의 7가지 원칙":"참고: ISTQB Foundation Level - Seven testing Principles\nISTQB 에서 정의하는 소프트웨어의 7가지 원칙은 아래와 같습니다.\nTesting shows the presence of defects, not their absence\n테스트는 결함의 부재가 아닌, 결함의 존재를 보여줘야 합니다.\n테스트를 통해 소프트웨어의 결함을 확인할 수 있습니다.\nExhaustive testing is impossible\n완벽한 테스트는 불가능합니다.\nEarly testing saves time and money\n일찍 진행한 테스트는 비용을 줄여줍니다.\nDefects cluster together\n결함은 집중되고 군집(클러스터)되는 경향이 있습니다.\nBeware of the pesticide paradox\n살충제 패러독스에 빠지지 않도록 해야합니다.\nTesting is context-dependent\n테스트는 주변 환경에 의존적입니다.\nAbsence-of-errors is a fallacy\n오류가 없다는 것은 오류입니다.","testing-shows-the-presence-of-defects-not-their-absence#Testing shows the presence of defects, not their absence":"테스트는 결함의 부재가 아닌, 결함의 존재를 보여줘야 합니다.\n테스트를 통해 소프트웨어의 결함을 확인할 수 있다.\n테스트는 소프트웨어의 결함을 찾기 위한 과정이며, 소프트웨어에 결함이 있다는 것을 보여주는 과정입니다. 테스트는 결함을 찾아가는 과정이며, 완전하게 오류가 없음을 보장하지는 않습니다. 다만 일정 수준의 테스트를 통해서 소프트웨어의 정상 작동 범위를 보장할 수 있고 신뢰성을 높일 수 있습니다.","exhaustive-testing-is-impossible#Exhaustive testing is impossible":"완벽한 테스트는 불가능합니다.\n모든 입력, 전제조건들을 일일이 테스트하는 것은 실제로는 불가능합니다. 테스트에 필요한 인적, 시간적 리소스는 한정적입니다. 따라서 필요한 기능과 정합성이 보장되어야 하는 요소를 적절하게 선정해서 테스트를 적용해야 합니다.","early-testing-saves-time-and-money#Early testing saves time and money":"일찍 진행한 테스트는 비용을 줄여줍니다.\n테스트는 일찍 진행할 수록 비용이 줄어듭니다. 요구사항 수립, 개발작업 사이에 먼저 테스트를 통해 발견한 버그는 QA 시에 발생하는 시간적, 인적 리소스를 줄여줍니다.","defects-cluster-together#Defects cluster together":"결함은 집중되고 군집(클러스터)되는 경향이 있습니다.\n결함은 특정 요소에 클러스터처럼 퍼져있는 경우가 많습니다.","beware-of-the-pesticide-paradox#Beware of the pesticide paradox":"살충제 패러독스에 빠지지 않도록 해야합니다.\n시간이 지남에 따라 동일한 테스트 케이스를 반복해서 수행하는 것은 지양해야 합니다. 동일한 테스트를 반복하면, 소프트웨어가 정상적으로 수행되는 것은 확인이 가능하지만, 새로운 문제는 발견해내지 못합니다.테스트를 정기적으로 업데이트하고 검토하면서 테스트를 개선시켜나가야 합니다.","testing-is-context-dependent#Testing is context-dependent":"테스트는 주변 환경에 의존적입니다.\n테스트는 주변 환경에 따라서 완전히 달라질 수 있습니다. 프로젝트 마다 요구되는 주변 상황, 환경 등을 고려해서 테스트의 환경을 커스터마이징해야 합니다. 예를 들면 증권 시세 데이터서비스와 원장 서비스는 환경이 다릅니다. 각각의 환경에 맞는 테스트 환경을 수립해야 합니다.","absence-of-errors-is-a-fallacy#Absence-of-errors is a fallacy":"오류가 없다는 것은 오류입니다.\n소프트웨어에 결함이 없다는 것이 단순히 소프트웨어에 결함이 없다는 것을 보장하지는 않습니다. 테스트의 목표를 100% 결함을 찾아내는 것에 목적을 두기보다 사용자에게 제공되는 기능이 올바른지를 검증하는 데에 목적을 두어야 합니다.","테스트의-목적#테스트의 목적":"테스트의 장점은 버그를 검증하거나, 특정 조건 내에서 이 기능이 꼭 성공함을 보장한다거나 특정 기능의 명세는 이런 요구사항을 가짐을 명세화할 경우 테스트는 장점을 가집니다. 완벽한 결함 제거 보다는 꼭 성공해야 하는 필수적인 기능에 대해 기능의 검증을 반복해서 자동화 기반으로 검증할 수 있다면 좋습니다.","테스트의-종류#테스트의 종류":"테스트의 종류는 단위테스트, 슬라이스테스트, 통합테스트가 있습니다. 이번 github 페이지에서는 이 내용들을 다룹니다."}},"/mockito-test":{"title":"Mockito Test","data":{"mockito-테스트#Mockito 테스트":""}}}