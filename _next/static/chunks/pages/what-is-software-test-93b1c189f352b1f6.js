(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[991],{4337:function(e,n,s){(window.__NEXT_P=window.__NEXT_P||[]).push(["/what-is-software-test",function(){return s(7024)}])},7024:function(e,n,s){"use strict";s.r(n),s.d(n,{__toc:function(){return h},default:function(){return o}});var t=s(5893),i=s(2673),r=s(373),l=s(8426);s(9128);var c=s(2643),d={src:"/docs-spring-reactive-test/_next/static/media/kind-of-tests.0b6f49d5.png",height:283,width:408,blurDataURL:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAAAAADbboAnAAAALUlEQVR42g3HgQkAMRACQftv9//WExKIIMMqf54fViaM3ShdVBaIettnVRluHuGsLlhwG03oAAAAAElFTkSuQmCC",blurWidth:8,blurHeight:6};let h=[{depth:2,value:"소프트웨어 테스트란?",id:"소프트웨어-테스트란"},{depth:2,value:"소프트웨어 테스트의 7가지 원칙",id:"소프트웨어-테스트의-7가지-원칙"},{depth:3,value:"Testing shows the presence of defects, not their absence",id:"testing-shows-the-presence-of-defects-not-their-absence"},{depth:3,value:"Exhaustive testing is impossible",id:"exhaustive-testing-is-impossible"},{depth:3,value:"Early testing saves time and money",id:"early-testing-saves-time-and-money"},{depth:3,value:"Defects cluster together",id:"defects-cluster-together"},{depth:3,value:"Beware of the pesticide paradox",id:"beware-of-the-pesticide-paradox"},{depth:3,value:"Testing is context-dependent",id:"testing-is-context-dependent"},{depth:3,value:"Absence-of-errors is a fallacy",id:"absence-of-errors-is-a-fallacy"},{depth:2,value:"테스트의 목적",id:"테스트의-목적"},{depth:2,value:"테스트의 종류",id:"테스트의-종류"}];function _createMdxContent(e){let n=Object.assign({h2:"h2",blockquote:"blockquote",p:"p",a:"a",ul:"ul",li:"li",strong:"strong",h3:"h3",img:"img"},(0,c.a)(),e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"소프트웨어-테스트란",children:"소프트웨어 테스트란?"}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["참고 : ",(0,t.jsx)(n.a,{href:"https://ko.wikipedia.org/wiki/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4_%ED%85%8C%EC%8A%A4%ED%8A%B8",children:"ko.wikipedia.org/wiki - 소프트웨어 테스트"})]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["소프트웨어 테스트는 주요 이해관계자들에게 시험 대상 제품, 서비스 품질에 대한 정보를 제공하는 조사과정입니다.",(0,t.jsx)("br",{})]}),"\n",(0,t.jsx)(n.p,{children:"소프트웨어 테스트는 아래의 특징들을 제공합니다."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"소프트웨어에 대한 객관적이고 독립적인 시각을 제공"}),"\n",(0,t.jsx)(n.li,{children:"사업 주체가 소프트웨어 구현의 위험성을 올바로 이해할 수 있도록 도움을 제공"}),"\n"]}),"\n",(0,t.jsx)("br",{}),"\n",(0,t.jsx)(n.h2,{id:"소프트웨어-테스트의-7가지-원칙",children:"소프트웨어 테스트의 7가지 원칙"}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["참고: ",(0,t.jsx)(n.a,{href:"https://astqb.org/istqb-foundation-level-seven-testing-principles/",children:"ISTQB Foundation Level - Seven testing Principles"})]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["ISTQB 에서 정의하는 소프트웨어의 7가지 원칙은 아래와 같습니다. 실무에서 느낀 테스트의 장점은 버그를 검증하거나, 특정 조건 내에서 이 기능이 꼭 성공함을 보장한다거나 이런 기능의 명세는 이런 요구사항을 가짐을 명세화하는 데에 있었습니다. 소프트웨어 테스트의 7가지 원칙은 이런 내용들을 설명합니다. ",(0,t.jsx)("br",{})]}),"\n",(0,t.jsxs)(n.p,{children:["예를 들면 테스트 커버리지를 100% 에 도달하게 하더라도, 이후의 비즈니스 요구사항 발생시 부가적인 테스트 코드 리팩토링 등의 작업이 발생하게 됩니다. 이런 부분에 맞춰서 요구사항의 핵심에 대응할 수 있는 부분들에 대해 적재 적소에 테스트케이스를 수립해갈 때 판단이 될 수 있는 원칙들로 ISTQB 에서는 아래의 7가지 원칙을 제시합니다.",(0,t.jsx)("br",{})]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Testing shows the presence of defects, not their absence"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"테스트는 결함의 부재가 아닌, 결함의 존재를 보여줘야 합니다."}),"\n",(0,t.jsx)(n.li,{children:"테스트를 통해 소프트웨어의 결함을 확인할 수 있습니다."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Exhaustive testing is impossible"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"완벽한 테스트는 불가능합니다."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Early testing saves time and money"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"일찍 진행한 테스트는 비용을 줄여줍니다."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Defects cluster together"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"결함은 집중되고 군집(클러스터)되는 경향이 있습니다."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Beware of the pesticide paradox"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"살충제 패러독스에 빠지지 않도록 해야합니다."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Testing is context-dependent"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"테스트는 주변 환경에 의존적입니다."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Absence-of-errors is a fallacy"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"오류가 없다는 것은 오류입니다."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)("br",{}),"\n",(0,t.jsx)(n.h3,{id:"testing-shows-the-presence-of-defects-not-their-absence",children:(0,t.jsx)(n.strong,{children:"Testing shows the presence of defects, not their absence"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"테스트는 결함의 부재가 아닌, 결함의 존재를 보여줘야 합니다."}),"\n",(0,t.jsx)(n.li,{children:"테스트를 통해 소프트웨어의 결함을 확인할 수 있다."}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["테스트는 소프트웨어의 결함을 찾기 위한 과정이며, 소프트웨어에 결함이 있다는 것을 보여주는 과정입니다. 테스트는 결함을 찾아가는 과정이며, 완전하게 오류가 없음을 보장하지는 않습니다. 다만 일정 수준의 테스트를 통해서 소프트웨어의 정상 작동 범위를 보장할 수 있고 신뢰성을 높일 수 있습니다.",(0,t.jsx)("br",{})]}),"\n",(0,t.jsx)(n.h3,{id:"exhaustive-testing-is-impossible",children:(0,t.jsx)(n.strong,{children:"Exhaustive testing is impossible"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"완벽한 테스트는 불가능합니다."}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["모든 입력, 전제조건들을 일일이 테스트하는 것은 실제로는 불가능합니다. 테스트에 필요한 인적, 시간적 리소스는 한정적입니다. 따라서 필요한 기능과 정합성이 보장되어야 하는 요소를 적절하게 선정해서 테스트를 적용해야 합니다.",(0,t.jsx)("br",{})]}),"\n",(0,t.jsx)(n.h3,{id:"early-testing-saves-time-and-money",children:(0,t.jsx)(n.strong,{children:"Early testing saves time and money"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"일찍 진행한 테스트는 비용을 줄여줍니다."}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["테스트는 일찍 진행할 수록 비용이 줄어듭니다. 요구사항 수립, 개발작업 사이에 먼저 테스트를 통해 발견한 버그는 QA 시에 발생하는 시간적, 인적 리소스를 줄여줍니다.",(0,t.jsx)("br",{})]}),"\n",(0,t.jsx)(n.h3,{id:"defects-cluster-together",children:(0,t.jsx)(n.strong,{children:"Defects cluster together"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"결함은 집중되고 군집(클러스터)되는 경향이 있습니다."}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["결함은 특정 요소에 클러스터처럼 퍼져있는 경우가 많습니다.",(0,t.jsx)("br",{})]}),"\n",(0,t.jsx)(n.h3,{id:"beware-of-the-pesticide-paradox",children:(0,t.jsx)(n.strong,{children:"Beware of the pesticide paradox"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"살충제 패러독스에 빠지지 않도록 해야합니다."}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["시간이 지남에 따라 동일한 테스트 케이스를 반복해서 수행하는 것은 지양해야 합니다. 동일한 테스트를 반복하면, 소프트웨어가 정상적으로 수행되는 것은 확인이 가능하지만, 새로운 문제는 발견해내지 못합니다.",(0,t.jsx)("br",{})]}),"\n",(0,t.jsxs)(n.p,{children:["테스트를 정기적으로 업데이트하고 검토하면서 테스트를 개선시켜나가야 합니다.",(0,t.jsx)("br",{})]}),"\n",(0,t.jsx)(n.h3,{id:"testing-is-context-dependent",children:(0,t.jsx)(n.strong,{children:"Testing is context-dependent"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"테스트는 주변 환경에 의존적입니다."}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["테스트는 주변 환경에 따라서 완전히 달라질 수 있습니다. 프로젝트 마다 요구되는 주변 상황, 환경 등을 고려해서 테스트의 환경을 커스터마이징해야 합니다. 예를 들면 증권 시세 데이터서비스와 원장 서비스는 환경이 다릅니다. 각각의 환경에 맞는 테스트 환경을 수립해야 합니다.",(0,t.jsx)("br",{})]}),"\n",(0,t.jsx)(n.h3,{id:"absence-of-errors-is-a-fallacy",children:(0,t.jsx)(n.strong,{children:"Absence-of-errors is a fallacy"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"오류가 없다는 것은 오류입니다."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"소프트웨어에 결함이 없다는 것이 단순히 소프트웨어에 결함이 없다는 것을 보장하지는 않습니다. 테스트의 목표를 100% 결함을 찾아내는 것에 목적을 두기보다 사용자에게 제공되는 기능이 올바른지를 검증하는 데에 목적을 두어야 합니다."}),"\n",(0,t.jsx)("br",{}),"\n",(0,t.jsx)(n.h2,{id:"테스트의-목적",children:"테스트의 목적"}),"\n",(0,t.jsxs)(n.p,{children:["테스트의 장점은 버그를 검증하거나, 특정 조건 내에서 이 기능이 꼭 성공함을 보장한다거나 특정 기능의 명세는 이런 요구사항을 가짐을 명세화할 경우 테스트는 장점을 가집니다. 완벽한 결함 제거 보다는 꼭 성공해야 하는 필수적인 기능에 대해 기능의 검증을 반복해서 자동화 기반으로 검증할 수 있다면 좋습니다.",(0,t.jsx)("br",{})]}),"\n",(0,t.jsx)("br",{}),"\n",(0,t.jsx)(n.h2,{id:"테스트의-종류",children:"테스트의 종류"}),"\n",(0,t.jsxs)(n.p,{children:["테스트의 종류는 단위테스트, 슬라이스테스트, 통합테스트가 있습니다. 이번 github 페이지에서는 이 내용들을 다룹니다.",(0,t.jsx)("br",{})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{placeholder:"blur",src:d})}),"\n",(0,t.jsx)("br",{})]})}let a={MDXContent:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,c.a)(),e.components);return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(_createMdxContent,{...e})}):_createMdxContent(e)},pageOpts:{filePath:"pages/what-is-software-test.mdx",route:"/what-is-software-test",timestamp:1712647801e3,pageMap:[{kind:"MdxPage",name:"index",route:"/"},{kind:"MdxPage",name:"what-is-software-test",route:"/what-is-software-test"},{kind:"Meta",data:{index:"Introduction",contact:{title:"Contact ↗",type:"page",href:"-",newWindow:!0},"what-is-software-test":"What Is Software Test"}}],flexsearch:{codeblocks:!0},title:"What Is Software Test",headings:h},pageNextRoute:"/what-is-software-test",nextraLayout:r.ZP,themeConfig:l.Z};var o=(0,i.j)(a)},8426:function(e,n,s){"use strict";var t=s(5893);s(7294);let i={logo:(0,t.jsx)("span",{children:"Docs Spring Reactive Test"}),project:{link:"https://github.com/chagchagchag/docs-spring-reactive-test"},docsRepositoryBase:"https://github.com/chagchagchag/docs-spring-reactive-test",footer:{text:"Nextra Docs Template"}};n.Z=i},5789:function(){}},function(e){e.O(0,[774,796,888,179],function(){return e(e.s=4337)}),_N_E=e.O()}]);